; IL65 internal library routines
;
; Written by Irmen de Jong (irmen@razorvine.net)
; License: GNU GPL 3.0, see LICENSE
;
; indent format: TABS, size=8


~ il65_lib_zp {
; note: separate block so the 64tass assembler can remove this when no zp restore is required

	asm {

; ---- store the Zeropage in a backup area
save_zeropage
		sei
		ldx  #2
-		lda  $00,x
		sta  zp_backup,x
		inx
		bne  -
		cli
		rts

restore_zeropage
		php
		pha
		txa
		pha
		sei

		lda  $a0		; save the current jiffy clock
		sta  zp_backup+$a0
		lda  $a1
		sta  zp_backup+$a1
		lda  $a2
		sta  zp_backup+$a2

		ldx  #2
-		lda  zp_backup-2,x
		sta  $00,x
		inx
		bne  -
		cli
		pla
		tax
		pla
		plp
		rts

zp_backup	.fill  256, 0

	}
}


~ il65_lib {
		; note: the following ZP scratch registers must be the same as in c64lib
		memory  .byte  SCRATCH_ZP1	= $02		; scratch register #1 in ZP
		memory  .byte  SCRATCH_ZP2	= $03		; scratch register #2 in ZP
		memory  .word  SCRATCH_ZPWORD1	= $fb		; scratch word in ZP ($fb/$fc)
		memory  .word  SCRATCH_ZPWORD2	= $fd		; scratch word in ZP ($fd/$fe)


	asm {

; ---- jmp (indirect) routines for register pairs containing the indirect address
jsr_indirect_nozpuse_AX
		sta  jsr_indirect_tmp
		stx  jsr_indirect_tmp+1
		jmp  (jsr_indirect_tmp)
jsr_indirect_nozpuse_AY
		sta  jsr_indirect_tmp
		sty  jsr_indirect_tmp+1
		jmp  (jsr_indirect_tmp)
jsr_indirect_nozpuse_XY
		stx  jsr_indirect_tmp
		sty  jsr_indirect_tmp+1
		jmp  (jsr_indirect_tmp)
jsr_indirect_tmp
		.byte 0, 0


jsr_indirect_AX
		sta  SCRATCH_ZP1
		stx  SCRATCH_ZP2
		jmp  (SCRATCH_ZP1)
jsr_indirect_AY
		sta  SCRATCH_ZP1
		sty  SCRATCH_ZP2
		jmp  (SCRATCH_ZP1)
jsr_indirect_XY
		stx  SCRATCH_ZP1
		sty  SCRATCH_ZP2
		jmp  (SCRATCH_ZP1)

	}


	asm  {

; ---- copy a 5 byte MFLT floating point variable to another place
;      input: X/Y = source address,  SCRATCH_ZPWORD1 = destination address
copy_mflt	stx  SCRATCH_ZP1
		sty  SCRATCH_ZPWORD1+1
		ldy  #0
		lda  (SCRATCH_ZP1),y
		sta  (SCRATCH_ZPWORD1),y
		iny
		lda  (SCRATCH_ZP1),y
		sta  (SCRATCH_ZPWORD1),y
		iny
		lda  (SCRATCH_ZP1),y
		sta  (SCRATCH_ZPWORD1),y
		iny
		lda  (SCRATCH_ZP1),y
		sta  (SCRATCH_ZPWORD1),y
		iny
		lda  (SCRATCH_ZP1),y
		sta  (SCRATCH_ZPWORD1),y
		ldy  SCRATCH_ZPWORD1+1
		rts
	}

	asm  {

; ---- add 1 to the MFLT pointed to by X/Y.  Clobbers A, X, Y
float_add_one
		stx  SCRATCH_ZP1
		sty  SCRATCH_ZP2
		txa
		jsr  c64.MOVFM		; fac1 = float XY
		lda  #<c64.FL_FONE
		ldy  #>c64.FL_FONE
		jsr  c64.FADD		; fac1 += 1
		ldx  SCRATCH_ZP1
		ldy  SCRATCH_ZP2
		jmp  c64.FTOMEMXY	; float XY = fac1

; ---- subtract 1 from the MFLT pointed to by X/Y.  Clobbers A, X, Y
float_sub_one
		stx  SCRATCH_ZP1
		sty  SCRATCH_ZP2
		lda  #<c64.FL_FONE
		ldy  #>c64.FL_FONE
		jsr  c64.MOVFM		; fac1 = 1
		txa
		ldy  SCRATCH_ZP2
		jsr  c64.FSUB		; fac1 = float XY - 1
		ldx  SCRATCH_ZP1
		ldy  SCRATCH_ZP2
		jmp  c64.FTOMEMXY	; float XY = fac1

	}
}
