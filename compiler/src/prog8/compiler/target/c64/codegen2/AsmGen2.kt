package prog8.compiler.target.c64.codegen2

import prog8.ast.IFunctionCall
import prog8.ast.Node
import prog8.ast.Program
import prog8.ast.antlr.escape
import prog8.ast.base.*
import prog8.ast.expressions.*
import prog8.ast.statements.*
import prog8.compiler.*
import prog8.compiler.target.c64.AssemblyProgram
import prog8.compiler.target.c64.MachineDefinition
import prog8.compiler.target.c64.MachineDefinition.C64Zeropage
import prog8.compiler.target.c64.MachineDefinition.ESTACK_HI_HEX
import prog8.compiler.target.c64.MachineDefinition.ESTACK_HI_PLUS1_HEX
import prog8.compiler.target.c64.MachineDefinition.ESTACK_LO_HEX
import prog8.compiler.target.c64.MachineDefinition.ESTACK_LO_PLUS1_HEX
import prog8.compiler.target.c64.MachineDefinition.ESTACK_LO_PLUS2_HEX
import prog8.compiler.target.c64.Petscii
import prog8.functions.BuiltinFunctions
import java.io.File
import java.math.RoundingMode
import java.util.*
import kotlin.math.absoluteValue


internal class AssemblyError(msg: String) : RuntimeException(msg)


internal class AsmGen2(val program: Program,
                       val options: CompilationOptions,
                       val zeropage: Zeropage) {

    private val assemblyLines = mutableListOf<String>()
    private val globalFloatConsts = mutableMapOf<Double, String>()     // all float values in the entire program (value -> varname)
    private val allocatedZeropageVariables = mutableMapOf<String, Pair<Int, DataType>>()
    private val breakpointLabels = mutableListOf<String>()
    private val builtinFunctionsAsmGen = BuiltinFunctionsAsmGen(program, options, zeropage, this)

    internal fun compileToAssembly(optimize: Boolean): AssemblyProgram {
        assemblyLines.clear()
        println("Generating assembly code... ")

        header()
        val allBlocks = program.allBlocks()
        if(allBlocks.first().name != "main")
            throw AssemblyError("first block should be 'main'")
        for(b in program.allBlocks())
            block2asm(b)
        footer()

        if(optimize) {
            var optimizationsDone = 1
            while (optimizationsDone > 0) {
                optimizationsDone = optimizeAssembly(assemblyLines)
            }
        }

        File("${program.name}.asm").printWriter().use {
            for (line in assemblyLines) { it.println(line) }
        }

        return AssemblyProgram(program.name)
    }

    private fun header() {
        val ourName = this.javaClass.name
        out("; 6502 assembly code for '${program.name}'")
        out("; generated by $ourName on ${Date()}")
        out("; assembler syntax is for the 64tasm cross-assembler")
        out("; output options: output=${options.output} launcher=${options.launcher} zp=${options.zeropage}")
        out("\n.cpu  '6502'\n.enc  'none'\n")

        program.actualLoadAddress = program.definedLoadAddress
        if (program.actualLoadAddress == 0)   // fix load address
            program.actualLoadAddress = if (options.launcher == LauncherType.BASIC)
                MachineDefinition.BASIC_LOAD_ADDRESS else MachineDefinition.RAW_LOAD_ADDRESS

        when {
            options.launcher == LauncherType.BASIC -> {
                if (program.actualLoadAddress != 0x0801)
                    throw AssemblyError("BASIC output must have load address $0801")
                out("; ---- basic program with sys call ----")
                out("* = ${program.actualLoadAddress.toHex()}")
                val year = Calendar.getInstance().get(Calendar.YEAR)
                out("  .word  (+), $year")
                out("  .null  $9e, format(' %d ', _prog8_entrypoint), $3a, $8f, ' prog8 by idj'")
                out("+\t.word  0")
                out("_prog8_entrypoint\t; assembly code starts here\n")
                out("  jsr  prog8_lib.init_system")
            }
            options.output == OutputType.PRG -> {
                out("; ---- program without basic sys call ----")
                out("* = ${program.actualLoadAddress.toHex()}\n")
                out("  jsr  prog8_lib.init_system")
            }
            options.output == OutputType.RAW -> {
                out("; ---- raw assembler program ----")
                out("* = ${program.actualLoadAddress.toHex()}\n")
            }
        }

        if (zeropage.exitProgramStrategy != Zeropage.ExitProgramStrategy.CLEAN_EXIT) {
            // disable shift-commodore charset switching and run/stop key
            out("  lda  #$80")
            out("  lda  #$80")
            out("  sta  657\t; disable charset switching")
            out("  lda  #239")
            out("  sta  808\t; disable run/stop key")
        }

        out("  ldx  #\$ff\t; init estack pointer")

        out("  ; initialize the variables in each block")
        for (block in program.allBlocks()) {
            val initVarsSub = block.statements.singleOrNull { it is Subroutine && it.name == initvarsSubName }
            if(initVarsSub!=null)
                out("  jsr  ${block.name}.$initvarsSubName")
        }

        out("  clc")
        when (zeropage.exitProgramStrategy) {
            Zeropage.ExitProgramStrategy.CLEAN_EXIT -> {
                out("  jmp  main.start\t; jump to program entrypoint")
            }
            Zeropage.ExitProgramStrategy.SYSTEM_RESET -> {
                out("  jsr  main.start\t; call program entrypoint")
                out("  jmp  (c64.RESET_VEC)\t; cold reset")
            }
        }
        out("")
    }

    private fun footer() {
        // the global list of all floating point constants for the whole program
        out("; global float constants")
        for (flt in globalFloatConsts) {
            val mflpt5 = MachineDefinition.Mflpt5.fromNumber(flt.key)
            val floatFill = makeFloatFill(mflpt5)
            val floatvalue = flt.key
            out("${flt.value}\t.byte  $floatFill  ; float $floatvalue")
        }
    }

    private fun block2asm(block: Block) {
        out("\n; ---- block: '${block.name}' ----")
        out("${block.name}\t.proc\n")           // TODO not if force_output?
        if(block.address!=null) {
            out(".cerror * > ${block.address.toHex()}, 'block address overlaps by ', *-${block.address.toHex()},' bytes'")
            out("* = ${block.address.toHex()}")
        }

        outputSourceLine(block)
        zeropagevars2asm(block.statements)
        memdefs2asm(block.statements)
        vardecls2asm(block.statements)
        out("\n; subroutines in this block")

        // first translate regular statements, and then put the subroutines at the end.
        val (subroutine, stmts) = block.statements.partition { it is Subroutine }
        stmts.forEach { translate(it) }
        subroutine.forEach { translateSubroutine(it as Subroutine) }

        out("\n\t.pend\n")              // TODO not if force_output?
    }

    private var generatedLabelSequenceNumber: Int = 0

    private fun makeLabel(postfix: String): String {
        generatedLabelSequenceNumber++
        return "_prog8_label_${generatedLabelSequenceNumber}_$postfix"
    }

    private fun outputSourceLine(node: Node) {
        out(" ;\tsrc line: ${node.position.file}:${node.position.line}")
    }

    internal fun out(str: String, splitlines: Boolean = true) {
        val fragment = (if(" | " in str) str.replace("|", "\n") else str).trim('\n')

        if (splitlines) {
            for (line in fragment.split('\n')) {
                val trimmed = if (line.startsWith(' ')) "\t" + line.trim() else line.trim()
                // trimmed = trimmed.replace(Regex("^\\+\\s+"), "+\t")  // sanitize local label indentation
                assemblyLines.add(trimmed)
            }
        } else assemblyLines.add(fragment)
    }

    private fun makeFloatFill(flt: MachineDefinition.Mflpt5): String {
        val b0 = "$" + flt.b0.toString(16).padStart(2, '0')
        val b1 = "$" + flt.b1.toString(16).padStart(2, '0')
        val b2 = "$" + flt.b2.toString(16).padStart(2, '0')
        val b3 = "$" + flt.b3.toString(16).padStart(2, '0')
        val b4 = "$" + flt.b4.toString(16).padStart(2, '0')
        return "$b0, $b1, $b2, $b3, $b4"
    }

    private fun encodeStr(str: String, dt: DataType): List<Short> {
        return when(dt) {
            DataType.STR -> {
                val bytes = Petscii.encodePetscii(str, true)
                bytes.plus(0)
            }
            DataType.STR_S -> {
                val bytes = Petscii.encodeScreencode(str, true)
                bytes.plus(0)
            }
            else -> throw AssemblyError("invalid str type")
        }
    }

    private fun zeropagevars2asm(statements: List<Statement>) {
        out("; vars allocated on zeropage")
        val variables = statements.filterIsInstance<VarDecl>().filter { it.type==VarDeclType.VAR }
        for(variable in variables) {
            // should NOT allocate subroutine parameters on the zero page
            val fullName = variable.scopedname
            val zpVar = allocatedZeropageVariables[fullName]
            if(zpVar==null) {
                // This var is not on the ZP yet. Attempt to move it there (if it's not a float, those take up too much space)
                if(variable.zeropage != ZeropageWish.NOT_IN_ZEROPAGE &&
                        variable.datatype in zeropage.allowedDatatypes
                        && variable.datatype != DataType.FLOAT) {
                    try {
                        val address = zeropage.allocate(fullName, variable.datatype, null)
                        out("${variable.name} = $address\t; auto zp ${variable.datatype}")
                        // make sure we add the var to the set of zpvars for this block
                        allocatedZeropageVariables[fullName] = Pair(address, variable.datatype)
                    } catch (x: ZeropageDepletedError) {
                        // leave it as it is.
                    }
                }
            }
            else {
                throw AssemblyError("huh, var is already on zp  $zpVar")
                // it was already allocated on the zp, what to do?
                // out("${variable.name} = ${zpVar.first}\t; zp ${zpVar.second}")
            }
        }
    }

    private fun vardecl2asm(decl: VarDecl) {
        when (decl.datatype) {
            DataType.UBYTE -> out("${decl.name}\t.byte  0")
            DataType.BYTE -> out("${decl.name}\t.char  0")
            DataType.UWORD -> out("${decl.name}\t.word  0")
            DataType.WORD -> out("${decl.name}\t.sint  0")
            DataType.FLOAT -> out("${decl.name}\t.byte  0,0,0,0,0  ; float")
            DataType.STRUCT -> {}       // is flattened
            DataType.STR, DataType.STR_S -> {
                val string = (decl.value as ReferenceLiteralValue).str!!
                val encoded = encodeStr(string, decl.datatype)
                outputStringvar(decl, encoded)
            }
            DataType.ARRAY_UB -> {
                val data = makeArrayFillDataUnsigned(decl)
                if (data.size <= 16)
                    out("${decl.name}\t.byte  ${data.joinToString()}")
                else {
                    out(decl.name)
                    for (chunk in data.chunked(16))
                        out("  .byte  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_B -> {
                val data = makeArrayFillDataSigned(decl)
                if (data.size <= 16)
                    out("${decl.name}\t.char  ${data.joinToString()}")
                else {
                    out(decl.name)
                    for (chunk in data.chunked(16))
                        out("  .char  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_UW -> {
                val data = makeArrayFillDataUnsigned(decl)
                if (data.size <= 16)
                    out("${decl.name}\t.word  ${data.joinToString()}")
                else {
                    out(decl.name)
                    for (chunk in data.chunked(16))
                        out("  .word  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_W -> {
                val data = makeArrayFillDataSigned(decl)
                if (data.size <= 16)
                    out("${decl.name}\t.sint  ${data.joinToString()}")
                else {
                    out(decl.name)
                    for (chunk in data.chunked(16))
                        out("  .sint  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_F -> {
                val array = (decl.value as ReferenceLiteralValue).array
                if(array==null)
                    TODO("fix this")
                val floatFills = array.map {
                    val number = (it as NumericLiteralValue).number
                    makeFloatFill(MachineDefinition.Mflpt5.fromNumber(number))
                }
                out(decl.name)
                for (f in array.zip(floatFills))
                    out("  .byte  ${f.second}  ; float ${f.first}")
            }
        }
    }

    private fun memdefs2asm(statements: List<Statement>) {
        out("\n; memdefs and kernel subroutines")
        val memvars = statements.filterIsInstance<VarDecl>().filter { it.type==VarDeclType.MEMORY || it.type==VarDeclType.CONST }
        for(m in memvars) {
            out("  ${m.name} = ${(m.value as NumericLiteralValue).number.toHex()}")
        }
        val asmSubs = statements.filterIsInstance<Subroutine>().filter { it.isAsmSubroutine }
        for(sub in asmSubs) {
            if(sub.asmAddress!=null) {
                if(sub.statements.isNotEmpty())
                    throw AssemblyError("kernel subroutine cannot have statements")
                out("  ${sub.name} = ${sub.asmAddress.toHex()}")
            }
        }
    }

    private fun vardecls2asm(statements: List<Statement>) {
        out("\n; non-zeropage variables")
        val vars = statements.filterIsInstance<VarDecl>().filter { it.type==VarDeclType.VAR }

        // first output the flattened struct member variables *in order*
        // after that, the other variables sorted by their datatype

        val (structMembers, normalVars) = vars.partition { it.struct!=null }
        structMembers.forEach { vardecl2asm(it) }

        // special treatment for string types: merge strings that are identical
        val encodedstringVars = normalVars
                .filter {it.datatype in StringDatatypes }
                .map { it to encodeStr((it.value as ReferenceLiteralValue).str!!, it.datatype) }
                .groupBy({it.second}, {it.first})
        for((encoded, variables) in encodedstringVars) {
            variables.dropLast(1).forEach { out(it.name) }
            val lastvar = variables.last()
            outputStringvar(lastvar, encoded)
        }

        // non-string variables
        normalVars.filter{ it.datatype !in StringDatatypes}.sortedBy { it.datatype }.forEach {
            if(it.scopedname !in allocatedZeropageVariables)
                vardecl2asm(it)
        }
    }

    private fun outputStringvar(lastvar: VarDecl, encoded: List<Short>) {
        val string = (lastvar.value as ReferenceLiteralValue).str!!
        out("${lastvar.name}\t; ${lastvar.datatype} \"${escape(string).replace("\u0000", "<NULL>")}\"")
        val outputBytes = encoded.map { "$" + it.toString(16).padStart(2, '0') }
        for (chunk in outputBytes.chunked(16))
            out("  .byte  " + chunk.joinToString())
    }

    private fun makeArrayFillDataUnsigned(decl: VarDecl): List<String> {
        val array = (decl.value as ReferenceLiteralValue).array
        if(array==null)
            TODO("fix this")
        return when {
            decl.datatype == DataType.ARRAY_UB ->
                // byte array can never contain pointer-to types, so treat values as all integers
                array.map {
                    val number = (it as NumericLiteralValue).number.toInt()
                    "$"+number.toString(16).padStart(2, '0')
                }
            decl.datatype== DataType.ARRAY_UW -> array.map {
                val number = (it as NumericLiteralValue).number.toInt()
                // TODO word array with address-references
                "$"+number.toString(16).padStart(4, '0')
            }
            else -> throw AssemblyError("invalid arraysize type")
        }
    }

    private fun makeArrayFillDataSigned(decl: VarDecl): List<String> {
        val array = (decl.value as ReferenceLiteralValue).array
        if(array==null)
            TODO("fix this ${decl.value}")

        return when {
            decl.datatype == DataType.ARRAY_UB ->
                // byte array can never contain pointer-to types, so treat values as all integers
                array.map {
                    val number = (it as NumericLiteralValue).number.toInt()
                    val hexnum = number.toString(16).padStart(2, '0')
                    "$$hexnum"
                }
            decl.datatype == DataType.ARRAY_B ->
                // byte array can never contain pointer-to types, so treat values as all integers
                array.map {
                    val number = (it as NumericLiteralValue).number.toInt()
                    val hexnum = number.absoluteValue.toString(16).padStart(2, '0')
                    if(number>=0)
                        "$$hexnum"
                    else
                        "-$$hexnum"
                }
            decl.datatype== DataType.ARRAY_UW -> array.map {
                val number = (it as NumericLiteralValue).number.toInt()
                val hexnum = number.toString(16).padStart(4, '0')
                "$$hexnum"
            }
            decl.datatype== DataType.ARRAY_W -> array.map {
                val number = (it as NumericLiteralValue).number.toInt()
                val hexnum = number.absoluteValue.toString(16).padStart(4, '0')
                if(number>=0)
                    "$$hexnum"
                else
                    "-$$hexnum"
            }
            else -> throw AssemblyError("invalid arraysize type ${decl.datatype}")
        }
    }

    private fun getFloatConst(number: Double): String {
        // try to match the ROM float constants to save memory
        val mflpt5 = MachineDefinition.Mflpt5.fromNumber(number)
        val floatbytes = shortArrayOf(mflpt5.b0, mflpt5.b1, mflpt5.b2, mflpt5.b3, mflpt5.b4)
        when {
            floatbytes.contentEquals(shortArrayOf(0x00, 0x00, 0x00, 0x00, 0x00)) -> return "c64flt.FL_ZERO"
            floatbytes.contentEquals(shortArrayOf(0x82, 0x49, 0x0f, 0xda, 0xa1)) -> return "c64flt.FL_PIVAL"
            floatbytes.contentEquals(shortArrayOf(0x90, 0x80, 0x00, 0x00, 0x00)) -> return "c64flt.FL_N32768"
            floatbytes.contentEquals(shortArrayOf(0x81, 0x00, 0x00, 0x00, 0x00)) -> return "c64flt.FL_FONE"
            floatbytes.contentEquals(shortArrayOf(0x80, 0x35, 0x04, 0xf3, 0x34)) -> return "c64flt.FL_SQRHLF"
            floatbytes.contentEquals(shortArrayOf(0x81, 0x35, 0x04, 0xf3, 0x34)) -> return "c64flt.FL_SQRTWO"
            floatbytes.contentEquals(shortArrayOf(0x80, 0x80, 0x00, 0x00, 0x00)) -> return "c64flt.FL_NEGHLF"
            floatbytes.contentEquals(shortArrayOf(0x80, 0x31, 0x72, 0x17, 0xf8)) -> return "c64flt.FL_LOG2"
            floatbytes.contentEquals(shortArrayOf(0x84, 0x20, 0x00, 0x00, 0x00)) -> return "c64flt.FL_TENC"
            floatbytes.contentEquals(shortArrayOf(0x9e, 0x6e, 0x6b, 0x28, 0x00)) -> return "c64flt.FL_NZMIL"
            floatbytes.contentEquals(shortArrayOf(0x80, 0x00, 0x00, 0x00, 0x00)) -> return "c64flt.FL_FHALF"
            floatbytes.contentEquals(shortArrayOf(0x81, 0x38, 0xaa, 0x3b, 0x29)) -> return "c64flt.FL_LOGEB2"
            floatbytes.contentEquals(shortArrayOf(0x81, 0x49, 0x0f, 0xda, 0xa2)) -> return "c64flt.FL_PIHALF"
            floatbytes.contentEquals(shortArrayOf(0x83, 0x49, 0x0f, 0xda, 0xa2)) -> return "c64flt.FL_TWOPI"
            floatbytes.contentEquals(shortArrayOf(0x7f, 0x00, 0x00, 0x00, 0x00)) -> return "c64flt.FL_FR4"
            else -> {
                // attempt to correct for a few rounding issues
                when (number.toBigDecimal().setScale(10, RoundingMode.HALF_DOWN).toDouble()) {
                    3.1415926536 -> return "c64flt.FL_PIVAL"
                    1.4142135624 -> return "c64flt.FL_SQRTWO"
                    0.7071067812 -> return "c64flt.FL_SQRHLF"
                    0.6931471806 -> return "c64flt.FL_LOG2"
                    else -> {}
                }

                // no ROM float const for this value, create our own
                val name = globalFloatConsts[number]
                if(name!=null)
                    return name
                val newName = "prog8_float_const_${globalFloatConsts.size}"
                globalFloatConsts[number] = newName
                return newName
            }
        }
    }

    private fun signExtendAtoMsb(destination: String) =
            """
        ora  #$7f
        bmi  +
        lda  #0
+       sta  $destination
        """

    private fun asmIdentifierName(identifier: IdentifierReference): String {
        val name = if(identifier.memberOfStruct(program.namespace)!=null) {
            identifier.targetVarDecl(program.namespace)!!.name
        } else {
            identifier.nameInSource.joinToString(".")
        }
        return fixNameSymbols(name)
    }

    private fun fixNameSymbols(name: String) = name.replace("<", "prog8_").replace(">", "")     // take care of the autogenerated invalid (anon) label names

    private fun branchInstruction(condition: BranchCondition, complement: Boolean) =
            if(complement) {
                when (condition) {
                    BranchCondition.CS -> "bcc"
                    BranchCondition.CC -> "bcs"
                    BranchCondition.EQ, BranchCondition.Z -> "beq"
                    BranchCondition.NE, BranchCondition.NZ -> "bne"
                    BranchCondition.VS -> "bvc"
                    BranchCondition.VC -> "bvs"
                    BranchCondition.MI, BranchCondition.NEG -> "bmi"
                    BranchCondition.PL, BranchCondition.POS -> "bpl"
                }
            } else {
                when (condition) {
                    BranchCondition.CS -> "bcs"
                    BranchCondition.CC -> "bcc"
                    BranchCondition.EQ, BranchCondition.Z -> "beq"
                    BranchCondition.NE, BranchCondition.NZ -> "bne"
                    BranchCondition.VS -> "bvs"
                    BranchCondition.VC -> "bvc"
                    BranchCondition.MI, BranchCondition.NEG -> "bmi"
                    BranchCondition.PL, BranchCondition.POS -> "bpl"
                }
            }

    private fun argumentTypeCompatible(argType: DataType, paramType: DataType): Boolean {
        if(argType isAssignableTo paramType)
            return true

        // we have a special rule for some types.
        // strings are assignable to UWORD, for example, and vice versa
        if(argType in StringDatatypes && paramType==DataType.UWORD)
            return true
        if(argType==DataType.UWORD && paramType in StringDatatypes)
            return true

        return false
    }

    private fun readAndPushArrayvalueWithIndexA(arrayDt: DataType, variablename: String) {
        when (ArrayElementTypes.getValue(arrayDt).memorySize()) {
            1 -> {}
            2 -> out("  asl  a")
            5 -> out("  sta  ${C64Zeropage.SCRATCH_REG} |  asl  a |  asl  a  | clc |  adc  ${C64Zeropage.SCRATCH_REG}")
            else -> throw AssemblyError("invalid memory size")
        }
        when (arrayDt) {
            DataType.STR, DataType.STR_S, DataType.ARRAY_UB, DataType.ARRAY_B ->
                out("  tay |  lda  $variablename,y |  sta  $ESTACK_LO_HEX,x |  dex")
            DataType.ARRAY_UW, DataType.ARRAY_W ->
                out("  tay |  lda  $variablename,y |  sta  $ESTACK_LO_HEX,x |  iny |  lda  $variablename,y |  sta  $ESTACK_HI_HEX,x | dex")
            DataType.ARRAY_F ->
                out("""
                    sta  $ESTACK_LO_HEX,x
                    dex
                    jsr  c64flt.push_float_from_indexed_var
                """)
            else ->
                throw AssemblyError("weird array type")
        }
    }

    private fun saveRegister(register: Register) {
        when(register) {
            Register.A -> out("  pha")
            Register.X -> out("  txa | pha")
            Register.Y -> out("  tya | pha")
        }
    }

    private fun restoreRegister(register: Register) {
        when(register) {
            Register.A -> out("  pla")
            Register.X -> out("  pla | tax")
            Register.Y -> out("  pla | tay")
        }
    }

    private fun translateSubroutine(sub: Subroutine) {
        out("")
        outputSourceLine(sub)

        if(sub.isAsmSubroutine) {
            if(sub.asmAddress!=null)
                return  // already done at the memvars section

            // asmsub with most likely just an inline asm in it
            out("${sub.name}\t.proc")
            sub.statements.forEach{ translate(it) }
            out("  .pend\n")
        } else {
            // regular subroutine
            out("${sub.name}\t.proc")
            zeropagevars2asm(sub.statements)
            memdefs2asm(sub.statements)
            out("; statements")
            sub.statements.forEach{ translate(it) }
            out("; variables")
            vardecls2asm(sub.statements)
            out("  .pend\n")
        }
    }

    private fun translate(stmt: Statement) {
        outputSourceLine(stmt)
        when(stmt) {
            is VarDecl, is StructDecl, is NopStatement -> {}
            is Directive -> translate(stmt)
            is Return -> translate(stmt)
            is Subroutine -> translateSubroutine(stmt)
            is InlineAssembly -> translate(stmt)
            is FunctionCallStatement -> {
                val functionName = stmt.target.nameInSource.last()
                val builtinFunc = BuiltinFunctions[functionName]
                if(builtinFunc!=null) {
                    builtinFunctionsAsmGen.translateFunctioncallStatement(stmt, builtinFunc)
                } else {
                    translateSubroutineCall(stmt)
                    // discard any results from the stack:
                    val returns = stmt.target.targetSubroutine(program.namespace)!!.returntypes
                    for(t in returns) {
                        if (t in IntegerDatatypes || t in PassByReferenceDatatypes) out("  inx")
                        else if (t == DataType.FLOAT) out("  inx |  inx |  inx")
                    }
                }
            }
            is Assignment -> translate(stmt)
            is Jump -> translate(stmt)
            is PostIncrDecr -> translate(stmt)
            is Label -> translate(stmt)
            is BranchStatement -> translate(stmt)
            is IfStatement -> translate(stmt)
            is ForLoop -> translate(stmt)
            is Continue -> TODO("continue")
            is Break -> TODO("break")
            is WhileLoop -> translate(stmt)
            is RepeatLoop -> translate(stmt)
            is WhenStatement -> translate(stmt)
            is BuiltinFunctionStatementPlaceholder -> throw AssemblyError("builtin function should not have placeholder anymore?")
            is AnonymousScope -> translate(stmt)
            is Block -> throw AssemblyError("block should have been handled elsewhere")
        }
    }

    private fun translateSubroutineCall(stmt: IFunctionCall) {
        val sub = stmt.target.targetSubroutine(program.namespace) ?: throw AssemblyError("undefined subroutine ${stmt.target}")
        if(Register.X in sub.asmClobbers)
            out("  stx  c64.SCRATCH_ZPREGX")        // we only save X for now (required! is the eval stack pointer), screw A and Y...

        val subName = asmIdentifierName(stmt.target)
        if(stmt.arglist.isNotEmpty()) {
            for(arg in sub.parameters.withIndex().zip(stmt.arglist)) {
                translateSubroutineArgument(arg.first, arg.second, sub)
            }
        }
        out("  jsr  $subName")

        if(Register.X in sub.asmClobbers)
            out("  ldx  c64.SCRATCH_ZPREGX")        // restore X again
    }

    private fun translateSubroutineArgument(arg: IndexedValue<SubroutineParameter>, value: Expression, sub: Subroutine) {
        val sourceDt = value.inferType(program)!!
        if(!argumentTypeCompatible(sourceDt, arg.value.type))
            throw AssemblyError("argument type incompatible")
        if(sub.asmParameterRegisters.isEmpty()) {
            // pass arg via a variable
            val paramVar = arg.value
            val scopedParamVar = (sub.scopedname+"."+paramVar.name).split(".")
            val target = AssignTarget(null, IdentifierReference(scopedParamVar, sub.position), null, null, sub.position)
            target.linkParents(value.parent)
            when (value) {
                is NumericLiteralValue -> {
                    // optimize when the argument is a constant literal
                    when(arg.value.type) {
                        in ByteDatatypes -> assignFromByteConstant(target, value.number.toShort())
                        in WordDatatypes -> assignFromWordConstant(target, value.number.toInt())
                        DataType.FLOAT -> assignFromFloatConstant(target, value.number.toDouble())
                        in PassByReferenceDatatypes -> throw AssemblyError("can't pass string/array as arguments?")
                        else -> throw AssemblyError("weird arg datatype")
                    }
                }
                is IdentifierReference -> {
                    // optimize when the argument is a variable
                    when (arg.value.type) {
                        in ByteDatatypes -> assignFromByteVariable(target, value)
                        in WordDatatypes -> assignFromWordVariable(target, value)
                        DataType.FLOAT -> assignFromFloatVariable(target, value)
                        in PassByReferenceDatatypes -> throw AssemblyError("can't pass string/array as arguments?")
                        else -> throw AssemblyError("weird arg datatype")
                    }
                }
                is RegisterExpr -> {
                    assignFromRegister(target, value.register)
                }
                is DirectMemoryRead -> {
                    when(value.addressExpression) {
                        is NumericLiteralValue -> {
                            val address = (value.addressExpression as NumericLiteralValue).number.toInt()
                            assignFromMemoryByte(target, address, null)
                        }
                        is IdentifierReference -> {
                            assignFromMemoryByte(target, null, value.addressExpression as IdentifierReference)
                        }
                        else -> {
                            translateExpression(value.addressExpression)
                            out("  jsr  prog8_lib.read_byte_from_address |  inx")
                            assignFromRegister(target, Register.A)
                        }
                    }
                }
                else -> {
                    translateExpression(value)
                    assignFromEvalResult(target)
                }
            }
        } else {
            // pass arg via a register parameter
            val paramRegister = sub.asmParameterRegisters[arg.index]
            val statusflag = paramRegister.statusflag
            val register = paramRegister.registerOrPair
            val stack = paramRegister.stack
            when {
                stack==true -> TODO("param on stack")
                statusflag!=null -> {
                    if (statusflag == Statusflag.Pc) {
                        // this param needs to be set last, right before the jsr
                        // for now, this is already enforced on the subroutine definition by the Ast Checker
                        when(value) {
                            is NumericLiteralValue -> {
                                val carrySet = value.number.toInt() != 0
                                out(if(carrySet) "  sec" else "  clc")
                            }
                            is IdentifierReference -> {
                                val sourceName = asmIdentifierName(value)
                                out("""
            lda  $sourceName
            beq  +
            sec  
            bcs  ++
+           clc
+
""")
                            }
                            is RegisterExpr -> {
                                when(value.register) {
                                    Register.A -> out("  cmp  #0")
                                    Register.X -> out("  txa")
                                    Register.Y -> out("  tya")
                                }
                                out("""
            beq  +
            sec
            bcs  ++
+           clc
+
""")
                            }
                            else -> {
                                translateExpression(value)
                                out("""
            inx                        
            lda  $ESTACK_LO_HEX,x
            beq  +
            sec  
            bcs  ++
+           clc
+
""")
                            }
                        }
                    }
                    else throw AssemblyError("can only use Carry as status flag parameter")
                }
                register!=null && register.name.length==1 -> {
                    when (value) {
                        is NumericLiteralValue -> {
                            val target = AssignTarget(Register.valueOf(register.name), null, null, null, sub.position)
                            target.linkParents(value.parent)
                            assignFromByteConstant(target, value.number.toShort())
                        }
                        is IdentifierReference -> {
                            val target = AssignTarget(Register.valueOf(register.name), null, null, null, sub.position)
                            target.linkParents(value.parent)
                            assignFromByteVariable(target, value)
                        }
                        else -> {
                            translateExpression(value)
                            when(register) {
                                RegisterOrPair.A -> out("  inx | lda  $ESTACK_LO_HEX,x")
                                RegisterOrPair.X -> throw AssemblyError("can't pop into X register - use a variable instead")
                                RegisterOrPair.Y -> out("  inx | ldy  $ESTACK_LO_HEX,x")
                                else -> throw AssemblyError("cannot assign to register pair")
                            }
                        }
                    }
                }
                register!=null && register.name.length==2 -> {
                    // register pair as a 16-bit value (only possible for subroutine parameters)
                    when (value) {
                        is NumericLiteralValue -> {
                            // optimize when the argument is a constant literal
                            val hex = value.number.toHex()
                            if (register == RegisterOrPair.AX)  out("  lda  #<$hex  |  ldx  #>$hex")
                            else if (register == RegisterOrPair.AY) out("  lda  #<$hex  |  ldy  #>$hex")
                            else if (register == RegisterOrPair.XY) out("  ldx  #<$hex  |  ldy  #>$hex")
                        }
                        is AddressOf -> {
                            // optimize when the argument is an address of something
                            val sourceName = asmIdentifierName(value.identifier)
                            if (register == RegisterOrPair.AX) out("  lda  #<$sourceName  |  ldx  #>$sourceName")
                            else if (register == RegisterOrPair.AY) out("  lda  #<$sourceName  |  ldy  #>$sourceName")
                            else if (register == RegisterOrPair.XY) out("  ldx  #<$sourceName  |  ldy  #>$sourceName")
                        }
                        is IdentifierReference -> {
                            val sourceName = asmIdentifierName(value)
                            if (register == RegisterOrPair.AX) out("  lda  $sourceName  |  ldx  $sourceName+1")
                            else if (register == RegisterOrPair.AY) out("  lda  $sourceName  |  ldy  $sourceName+1")
                            else if (register == RegisterOrPair.XY) out("  ldx  $sourceName  |  ldy  $sourceName+1")
                        }
                        else -> {
                            translateExpression(value)
                            if (register == RegisterOrPair.AX || register == RegisterOrPair.XY)
                                throw AssemblyError("can't use X register here - use a variable")
                            else if (register == RegisterOrPair.AY)
                                out("  inx |  lda  $ESTACK_LO_HEX,x  |  ldy  $ESTACK_HI_HEX,x")
                        }
                    }
                }
            }
        }
    }

    private fun translate(stmt: IfStatement) {
        translateExpression(stmt.condition)
        translateTestStack(stmt.condition.inferType(program)!!)
        val elseLabel = makeLabel("if_else")
        val endLabel = makeLabel("if_end")
        out("  beq  $elseLabel")
        translate(stmt.truepart)
        out("  jmp  $endLabel")
        out(elseLabel)
        translate(stmt.elsepart)
        out(endLabel)
    }

    private fun translateTestStack(dataType: DataType) {
        when(dataType) {
            in ByteDatatypes -> out("  inx |  lda  $ESTACK_LO_HEX,x")
            in WordDatatypes -> out("  inx |  lda  $ESTACK_LO_HEX,x |  ora  $ESTACK_HI_HEX,x")
            DataType.FLOAT -> throw AssemblyError("conditional value should be an integer (boolean)")
            else -> throw AssemblyError("non-numerical dt")
        }
    }

    private fun translate(stmt: WhileLoop) {
        TODO("while $stmt")
    }

    private fun translate(stmt: RepeatLoop) {
        // TODO("repeat $stmt")
        out(";------ TODO REPEAT")
        translate(stmt.body)
        out(";------ TODO REPEAT  END")
    }

    private fun translate(stmt: WhenStatement) {
        translateExpression(stmt.condition)
        val endLabel = makeLabel("choice_end")
        val choiceBlocks = mutableListOf<Pair<String, AnonymousScope>>()
        val conditionDt = stmt.condition.inferType(program)!!
        if(conditionDt in ByteDatatypes)
            out("  inx |  lda  $ESTACK_LO_HEX,x")
        else
            out("  inx |  lda  $ESTACK_LO_HEX,x |  ldy  $ESTACK_HI_HEX,x")
        for(choice in stmt.choices) {
            val choiceLabel = makeLabel("choice")
            if(choice.values==null) {
                // the else choice
                translate(choice.statements)
                out("  jmp  $endLabel")
            } else {
                choiceBlocks.add(Pair(choiceLabel, choice.statements))
                for (cv in choice.values!!) {
                    val value = (cv as NumericLiteralValue).number.toInt()
                    if(conditionDt in ByteDatatypes) {
                        out("  cmp  #${value.toHex()} |  beq  $choiceLabel")
                    } else {
                        out("""
                            cmp  #<${value.toHex()}
                            bne  +
                            cpy  #>${value.toHex()}
                            beq  $choiceLabel
+                            
                            """)
                    }
                }
            }
        }
        for(choiceBlock in choiceBlocks) {
            out(choiceBlock.first)
            translate(choiceBlock.second)
            out("  jmp  $endLabel")
        }
        out(endLabel)
    }

    private fun translate(stmt: Label) {
        out(stmt.name)
    }

    private fun translate(scope: AnonymousScope) {
        // note: the variables defined in an anonymous scope are moved to their defining subroutine's scope
        scope.statements.forEach{ translate(it) }
    }

    private fun translate(stmt: BranchStatement) {
        if(stmt.truepart.containsNoCodeNorVars() && stmt.elsepart.containsCodeOrVars())
            throw AssemblyError("only else part contains code, shoud have been switched already")

        val jump = stmt.truepart.statements.first() as? Jump
        if(jump!=null) {
            // branch with only a jump
            val instruction = branchInstruction(stmt.condition, false)
            out("  $instruction  ${getJumpTarget(jump)}")
            translate(stmt.elsepart)
        } else {
            if(stmt.elsepart.containsNoCodeNorVars()) {
                val instruction = branchInstruction(stmt.condition, true)
                val elseLabel = makeLabel("branch_else")
                out("  $instruction  $elseLabel")
                translate(stmt.truepart)
                out(elseLabel)
            } else {
                val instruction = branchInstruction(stmt.condition, false)
                val trueLabel = makeLabel("branch_true")
                val endLabel = makeLabel("branch_end")
                out("  $instruction  $trueLabel")
                translate(stmt.elsepart)
                out("  jmp  $endLabel")
                out(trueLabel)
                translate(stmt.truepart)
                out(endLabel)
            }
        }
    }

    private fun translate(stmt: Directive) {
        when(stmt.directive) {
            "%asminclude" -> {
                val sourcecode = loadAsmIncludeFile(stmt.args[0].str!!, stmt.definingModule().source)
                val scopeprefix = stmt.args[1].str ?: ""
                if(!scopeprefix.isBlank())
                    out("$scopeprefix\t.proc")
                assemblyLines.add(sourcecode.trimEnd().trimStart('\n'))
                if(!scopeprefix.isBlank())
                    out("  .pend\n")
            }
            "%asmbinary" -> {
                val offset = if(stmt.args.size>1) ", ${stmt.args[1].int}" else ""
                val length = if(stmt.args.size>2) ", ${stmt.args[2].int}" else ""
                out("  .binary \"${stmt.args[0].str}\" $offset $length")
            }
            "%breakpoint" -> {
                val label = "_prog8_breakpoint_${breakpointLabels.size+1}"
                breakpointLabels.add(label)
                out("$label\tnop")
            }
        }
    }

    private fun translate(stmt: ForLoop) {
        val iterableDt = stmt.iterable.inferType(program)
        val loopLabel = makeLabel("for_loop")
        val endLabel = makeLabel("for_end")
        when(stmt.iterable) {
            is RangeExpr -> {
                val range = (stmt.iterable as RangeExpr).toConstantIntegerRange()
                if(range==null)
                    TODO("non-const range loop")
                if(range.isEmpty())
                    throw AssemblyError("empty range")
                when(iterableDt) {
                    in ByteDatatypes -> {
                        if(stmt.loopRegister!=null) {

                            // loop register over range

                            if(stmt.loopRegister!=Register.A)
                                throw AssemblyError("can only use A")
                            when {
                                range.step==1 -> {
                                    // step = 1
                                    val counterLabel = makeLabel("for_counter")
                                    out("""
                lda  #${range.first}
                sta  $loopLabel+1
                lda  #${range.last-range.first+1 and 255}
                sta  $counterLabel
$loopLabel      lda  #0                 ; modified""")
                translate(stmt.body)
                out("""
                dec  $counterLabel
                beq  $endLabel
                inc  $loopLabel+1
                jmp  $loopLabel
$counterLabel   .byte  0                
$endLabel""")
                                }
                                range.step==-1 -> {
                                    // step = -1
                                    val counterLabel = makeLabel("for_counter")
                                    out("""
                lda  #${range.first}
                sta  $loopLabel+1
                lda  #${range.first-range.last+1 and 255}
                sta  $counterLabel
$loopLabel      lda  #0                 ; modified """)
                                    translate(stmt.body)
                                    out("""
                dec  $counterLabel
                beq  $endLabel
                dec  $loopLabel+1
                jmp  $loopLabel
$counterLabel   .byte  0                
$endLabel""")
                                }
                                range.step>0 -> {
                                    // step >= 2
                                    val counterLabel = makeLabel("for_counter")
                                    out("""
                lda  #${(range.last-range.first) / range.step + 1}
                sta  $counterLabel
                lda  #${range.first}
$loopLabel      pha""")
                                    translate(stmt.body)
                                    out("""
                pla
                dec  $counterLabel
                beq  $endLabel
                clc
                adc  #${range.step}
                jmp  $loopLabel
$counterLabel   .byte  0                
$endLabel""")
                                }
                                else -> {
                                    // step <= -2
                                    val counterLabel = makeLabel("for_counter")
                                    out("""
                lda  #${(range.first-range.last) / range.step.absoluteValue + 1}
                sta  $counterLabel
                lda  #${range.first}
$loopLabel      pha""")
                                    translate(stmt.body)
                                    out("""
                pla
                dec  $counterLabel
                beq  $endLabel
                sec
                sbc  #${range.step.absoluteValue}
                jmp  $loopLabel
$counterLabel   .byte  0                
$endLabel""")
                                }
                            }

                        } else {

                            // loop over byte range via loopvar
                            val varname = asmIdentifierName(stmt.loopVar!!)
                            when {
                                range.step==1 -> {
                                    // step = 1
                                    val counterLabel = makeLabel("for_counter")
                                    out("""
                lda  #${range.first}
                sta  $varname
                lda  #${range.last-range.first+1 and 255}
                sta  $counterLabel
$loopLabel""")
                                    translate(stmt.body)
                                    out("""
                dec  $counterLabel
                beq  $endLabel
                inc  $varname
                jmp  $loopLabel
$counterLabel   .byte  0                
$endLabel""")
                                }
                                range.step==-1 -> {
                                    // step = -1
                                    val counterLabel = makeLabel("for_counter")
                                    out("""
                lda  #${range.first}
                sta  $varname
                lda  #${range.first-range.last+1 and 255}
                sta  $counterLabel
$loopLabel""")
                                    translate(stmt.body)
                                    out("""
                dec  $counterLabel
                beq  $endLabel
                dec  $varname
                jmp  $loopLabel
$counterLabel   .byte  0                
$endLabel""")
                                }
                                range.step>0 -> {
                                    // step >= 2
                                    val counterLabel = makeLabel("for_counter")
                                    out("""
                lda  #${(range.last-range.first) / range.step + 1}
                sta  $counterLabel
                lda  #${range.first}
                sta  $varname
$loopLabel""")
                                    translate(stmt.body)
                                    out("""
                dec  $counterLabel
                beq  $endLabel
                lda  $varname
                clc
                adc  #${range.step}
                sta  $varname
                jmp  $loopLabel
$counterLabel   .byte  0                
$endLabel""")
                                }
                                else -> {
                                    // step <= -2
                                    val counterLabel = makeLabel("for_counter")
                                    out("""
                lda  #${(range.first-range.last) / range.step.absoluteValue + 1}
                sta  $counterLabel
                lda  #${range.first}
                sta  $varname
$loopLabel""")
                                    translate(stmt.body)
                                    out("""
                dec  $counterLabel
                beq  $endLabel
                lda  $varname
                sec
                sbc  #${range.step.absoluteValue}
                sta  $varname
                jmp  $loopLabel
$counterLabel   .byte  0                
$endLabel""")
                                }
                            }
                        }
                    }
                    in WordDatatypes -> {
                        TODO("forloop over word range $stmt") // TODO
                    }
                    else -> throw AssemblyError("range expression can only be byte or word")
                }
            }
            is IdentifierReference -> {
                val ident = (stmt.iterable as IdentifierReference)
                val iterableName = asmIdentifierName(ident)
                val decl = ident.targetVarDecl(program.namespace)!!
                when(iterableDt) {
                    DataType.STR, DataType.STR_S -> {
                        if(stmt.loopRegister!=null && stmt.loopRegister!=Register.A)
                            throw AssemblyError("can only use A")
                        out("""
                lda  #<$iterableName
                ldy  #>$iterableName
                sta  $loopLabel+1
                sty  $loopLabel+2
$loopLabel      lda  ${65535.toHex()}       ; modified
                beq  $endLabel""")
                        if(stmt.loopVar!=null)
                            out("  sta  ${asmIdentifierName(stmt.loopVar!!)}")
                        translate(stmt.body)
                        out("""
                inc  $loopLabel+1
                bne  $loopLabel
                inc  $loopLabel+2
                bne  $loopLabel
$endLabel""")
                    }
                    DataType.ARRAY_UB, DataType.ARRAY_B -> {
                        val length = decl.arraysize!!.size()
                        if(stmt.loopRegister!=null && stmt.loopRegister!=Register.A)
                            throw AssemblyError("can only use A")
                        val counterLabel = makeLabel("for_counter")
                        val modifiedLabel = makeLabel("for_modified")
                        out("""
                lda  #<$iterableName
                ldy  #>$iterableName
                sta  $modifiedLabel+1
                sty  $modifiedLabel+2
                ldy  #0
$loopLabel      sty  $counterLabel
                cpy  #$length
                beq  $endLabel
$modifiedLabel  lda  ${65535.toHex()},y       ; modified""")
                        if(stmt.loopVar!=null)
                            out("  sta  ${asmIdentifierName(stmt.loopVar!!)}")
                        translate(stmt.body)
                        out("""
                ldy  $counterLabel
                iny
                jmp  $loopLabel
$counterLabel   .byte  0
$endLabel""")
                    }
                    DataType.ARRAY_W, DataType.ARRAY_UW -> {
                        val length = decl.arraysize!!.size()
                        println("forloop over word array len $length  $stmt")    // TODO
                        if(stmt.loopRegister!=null) {
                            TODO("loop register over wordarray of len $length")
                        } else {
                            TODO("loop variable over wordarray of len $length")
                        }
                    }
                    DataType.ARRAY_F -> {
                        val length = decl.arraysize!!.size()
                        println("forloop over float array len $length  $stmt")   // TODO
                        if(stmt.loopRegister!=null) {
                            throw AssemblyError("can't use register to loop over floats")
                        } else {
                            TODO("loop variable over floatarray of len $length")
                        }
                    }
                    else -> throw AssemblyError("can't iterate over $iterableDt")
                }
            }
            else -> throw AssemblyError("can't iterate over ${stmt.iterable}")
        }
    }

    private fun translate(stmt: PostIncrDecr) {
        val incr = stmt.operator=="++"
        val targetIdent = stmt.target.identifier
        val targetMemory = stmt.target.memoryAddress
        val targetArrayIdx = stmt.target.arrayindexed
        val targetRegister = stmt.target.register
        when {
            targetRegister!=null -> {
                when(targetRegister) {
                    Register.A -> {
                        if(incr)
                            out("  clc |  adc  #1 ")
                        else
                            out("  sec |  sbc  #1 ")
                    }
                    Register.X -> {
                        if(incr) out("  inx") else out("  dex")
                    }
                    Register.Y -> {
                        if(incr) out("  iny") else out("  dey")
                    }
                }
            }
            targetIdent!=null -> {
                val what = asmIdentifierName(targetIdent)
                val dt = stmt.target.inferType(program, stmt)
                when (dt) {
                    in ByteDatatypes -> out(if (incr) "  inc  $what" else "  dec  $what")
                    in WordDatatypes -> {
                        if(incr)
                            out(" inc  $what |  bne  + |  inc  $what+1 |+")
                        else
                            out(" lda  $what |  bne  + |  dec  $what+1 |+ |  dec  $what")
                    }
                    DataType.FLOAT -> {
                        out("  lda  #<$what |  ldy  #>$what")
                        out(if(incr) "  jsr  c64flt.inc_var_f" else "  jsr  c64flt.dec_var_f")
                    }
                    else -> throw AssemblyError("need numeric type")
                }
            }
            targetMemory!=null -> {
                val addressExpr = targetMemory.addressExpression
                when (addressExpr) {
                    is NumericLiteralValue -> {
                        val what = addressExpr.number.toHex()
                        out(if(incr) "  inc  $what" else "  dec  $what")
                    }
                    is IdentifierReference -> {
                        val what = asmIdentifierName(addressExpr)
                        out(if(incr) "  inc  $what" else "  dec  $what")
                    }
                    else -> throw AssemblyError("weird target type $targetMemory")
                }
            }
            targetArrayIdx!=null -> {
                val index = targetArrayIdx.arrayspec.index
                val targetName = asmIdentifierName(targetArrayIdx.identifier)
                val elementDt = ArrayElementTypes.getValue(targetArrayIdx.identifier.targetVarDecl(program.namespace)!!.datatype)
                when(index) {
                    is NumericLiteralValue -> {
                        val indexValue = index.number.toInt() * elementDt.memorySize()
                        out(if(incr) "  inc  $targetName+$indexValue" else "  dec  $targetName+$indexValue")
                    }
                    is RegisterExpr -> {
                        TODO("postincrdecr $elementDt array $targetName [ $index ]")
                    }
                    is IdentifierReference -> {
                        TODO("postincrdecr $elementDt array $targetName [ $index ]")
                    }
                    else -> {
                        TODO("postincrdecr $elementDt array $targetName [ $index ]")
                    }
                }
            }
            else -> throw AssemblyError("weird target type ${stmt.target}")
        }
    }

    private fun translate(jmp: Jump) {
        out("  jmp  ${getJumpTarget(jmp)}")
    }

    private fun getJumpTarget(jmp: Jump): String {
        return when {
            jmp.identifier!=null -> asmIdentifierName(jmp.identifier)
            jmp.generatedLabel!=null -> jmp.generatedLabel
            jmp.address!=null -> jmp.address.toHex()
            else -> "????"
        }
    }

    private fun translate(ret: Return) {
        ret.value?.let { translateExpression(it) }
        out("  rts")
    }

    private fun translate(asm: InlineAssembly) {
        val assembly = asm.assembly.trimEnd().trimStart('\n')
        assemblyLines.add(assembly)
    }

    private fun translate(assign: Assignment) {
        if(assign.aug_op!=null)
            throw AssemblyError("aug-op assignments should have been transformed to normal ones")

        when(assign.value) {
            is NumericLiteralValue -> {
                val numVal = assign.value as NumericLiteralValue
                when(numVal.type) {
                    DataType.UBYTE, DataType.BYTE -> assignFromByteConstant(assign.target, numVal.number.toShort())
                    DataType.UWORD, DataType.WORD -> assignFromWordConstant(assign.target, numVal.number.toInt())
                    DataType.FLOAT -> assignFromFloatConstant(assign.target, numVal.number.toDouble())
                    else -> throw AssemblyError("weird numval type")
                }
            }
            is RegisterExpr -> {
                assignFromRegister(assign.target, (assign.value as RegisterExpr).register)
            }
            is IdentifierReference -> {
                val type = assign.target.inferType(program, assign)!!
                when(type) {
                    DataType.UBYTE, DataType.BYTE -> assignFromByteVariable(assign.target, assign.value as IdentifierReference)
                    DataType.UWORD, DataType.WORD -> assignFromWordVariable(assign.target, assign.value as IdentifierReference)
                    DataType.FLOAT -> assignFromFloatVariable(assign.target, assign.value as IdentifierReference)
                    else -> throw AssemblyError("unsupported assignment target type $type")
                }
            }
            is AddressOf -> {
                val identifier = (assign.value as AddressOf).identifier
                val scopedname = (assign.value as AddressOf).scopedname!!
                assignFromAddressOf(assign.target, identifier, scopedname)
            }
            is DirectMemoryRead -> {
                val read = (assign.value as DirectMemoryRead)
                when(read.addressExpression) {
                    is NumericLiteralValue -> {
                        val address = (read.addressExpression as NumericLiteralValue).number.toInt()
                        assignFromMemoryByte(assign.target, address, null)
                    }
                    is IdentifierReference -> {
                        assignFromMemoryByte(assign.target, null, read.addressExpression as IdentifierReference)
                    }
                    else -> {
                        translateExpression(read.addressExpression)
                        TODO("read memory byte from result and put that in ${assign.target}")
                    }
                }
            }
            is PrefixExpression -> {
                translateExpression(assign.value as PrefixExpression)
                assignFromEvalResult(assign.target)
            }
            is BinaryExpression -> {
                translateExpression(assign.value as BinaryExpression)
                assignFromEvalResult(assign.target)
            }
            is ArrayIndexedExpression -> {
                translateExpression(assign.value as ArrayIndexedExpression)
                assignFromEvalResult(assign.target)
            }
            is TypecastExpression -> {
                val cast = assign.value as TypecastExpression
                val sourceType = cast.expression.inferType(program)
                val targetType = assign.target.inferType(program, assign)
                if((sourceType in ByteDatatypes && targetType in ByteDatatypes) ||
                        (sourceType in WordDatatypes && targetType in WordDatatypes)) {
                    // no need for a type cast
                    assign.value = cast.expression
                    translate(assign)
                } else {
                    translateExpression(assign.value as TypecastExpression)
                    assignFromEvalResult(assign.target)
                }
            }
            is FunctionCall -> {
                translateExpression(assign.value as FunctionCall)
                assignFromEvalResult(assign.target)
            }
            is ReferenceLiteralValue -> TODO("string/array/struct assignment?")
            is StructLiteralValue -> throw AssemblyError("struct literal value assignment should have been flattened")
            is RangeExpr -> throw AssemblyError("range expression should have been changed into array values")
        }
    }

    private fun translateExpression(expr: ArrayIndexedExpression) {
        val arrayDt = expr.identifier.targetVarDecl(program.namespace)!!.datatype
        val sourceName = asmIdentifierName(expr.identifier)
        val index = expr.arrayspec.index
        when (index) {
            is NumericLiteralValue -> {
                val indexValue = index.number.toInt() * ArrayElementTypes.getValue(arrayDt).memorySize()
                when (arrayDt) {
                    DataType.STR, DataType.STR_S, DataType.ARRAY_UB, DataType.ARRAY_B ->
                        out("  lda  $sourceName+$indexValue |  sta  $ESTACK_LO_HEX,x |  dex")
                    DataType.ARRAY_UW, DataType.ARRAY_W ->
                        out("  lda  $sourceName+$indexValue |  sta  $ESTACK_LO_HEX,x |  lda  $sourceName+$indexValue+1 |  sta  $ESTACK_HI_HEX,x | dex")
                    DataType.ARRAY_F ->
                        out("  lda  #<$sourceName+$indexValue |  ldy  #>$sourceName+$indexValue |  jsr  c64flt.push_float")
                    else ->
                        throw AssemblyError("weird array type")
                }
            }
            is RegisterExpr -> {
                when (index.register) {
                    Register.A -> {}
                    Register.X -> out("  txa")
                    Register.Y -> out("  tya")
                }
                readAndPushArrayvalueWithIndexA(arrayDt, sourceName)
            }
            is IdentifierReference -> {
                val indexName = asmIdentifierName(index)
                out("  lda  $indexName")
                readAndPushArrayvalueWithIndexA(arrayDt, sourceName)
            }
            else -> {
                translateExpression(index)
                out("  inx |  lda  $ESTACK_LO_HEX,x")
                readAndPushArrayvalueWithIndexA(arrayDt, sourceName)
            }
        }
    }

    private fun translateExpression(expr: TypecastExpression) {
        translateExpression(expr.expression)
        when(expr.expression.inferType(program)!!) {
            DataType.UBYTE -> {
                when(expr.type) {
                    DataType.UBYTE, DataType.BYTE -> {}
                    DataType.UWORD, DataType.WORD -> out("  lda  #0  |  sta  $ESTACK_HI_PLUS1_HEX,x")
                    DataType.FLOAT -> out(" jsr  c64flt.stack_ub2float")
                    in PassByReferenceDatatypes -> throw AssemblyError("cannot cast to a pass-by-reference datatype")
                    else -> throw AssemblyError("weird type")
                }
            }
            DataType.BYTE -> {
                when(expr.type) {
                    DataType.UBYTE, DataType.BYTE -> {}
                    DataType.UWORD, DataType.WORD -> out("  lda  $ESTACK_HI_PLUS1_HEX,x  |  ${signExtendAtoMsb("$ESTACK_HI_PLUS1_HEX,x")}")
                    DataType.FLOAT -> out(" jsr  c64flt.stack_b2float")
                    in PassByReferenceDatatypes -> throw AssemblyError("cannot cast to a pass-by-reference datatype")
                    else -> throw AssemblyError("weird type")
                }
            }
            DataType.UWORD -> {
                when(expr.type) {
                    DataType.BYTE, DataType.UBYTE -> {}
                    DataType.WORD, DataType.UWORD -> {}
                    DataType.FLOAT -> out(" jsr  c64flt.stack_uw2float")
                    in PassByReferenceDatatypes -> throw AssemblyError("cannot cast to a pass-by-reference datatype")
                    else -> throw AssemblyError("weird type")
                }
            }
            DataType.WORD -> {
                when(expr.type) {
                    DataType.BYTE, DataType.UBYTE -> {}
                    DataType.WORD, DataType.UWORD -> {}
                    DataType.FLOAT -> out(" jsr  c64flt.stack_w2float")
                    in PassByReferenceDatatypes -> throw AssemblyError("cannot cast to a pass-by-reference datatype")
                    else -> throw AssemblyError("weird type")
                }
            }
            DataType.FLOAT -> {
                when(expr.type) {
                    DataType.UBYTE -> out(" jsr  c64flt.stack_float2uw")
                    DataType.BYTE -> out(" jsr  c64flt.stack_float2w")
                    DataType.UWORD -> out(" jsr  c64flt.stack_float2uw")
                    DataType.WORD -> out(" jsr  c64flt.stack_float2w")
                    DataType.FLOAT -> {}
                    in PassByReferenceDatatypes -> throw AssemblyError("cannot cast to a pass-by-reference datatype")
                    else -> throw AssemblyError("weird type")
                }
            }
            in PassByReferenceDatatypes -> throw AssemblyError("cannot case a pass-by-reference datatypes into something else")
            else -> throw AssemblyError("weird type")
        }
    }

    internal fun translateExpression(expression: Expression) {
        when(expression) {
            is PrefixExpression -> translateExpression(expression)
            is BinaryExpression -> translateExpression(expression)
            is ArrayIndexedExpression -> translateExpression(expression)
            is TypecastExpression -> translateExpression(expression)
            is AddressOf -> translateExpression(expression)
            is DirectMemoryRead -> translateExpression(expression)
            is NumericLiteralValue -> translateExpression(expression)
            is RegisterExpr -> translateExpression(expression)
            is IdentifierReference -> translateExpression(expression)
            is FunctionCall -> {
                val functionName = expression.target.nameInSource.last()
                val builtinFunc = BuiltinFunctions[functionName]
                if(builtinFunc!=null) {
                    builtinFunctionsAsmGen.translateFunctioncallExpression(expression, builtinFunc)
                } else {
                    translateSubroutineCall(expression)
                }
            }
            is ReferenceLiteralValue -> TODO("string/array/struct assignment?")
            is StructLiteralValue -> throw AssemblyError("struct literal value assignment should have been flattened")
            is RangeExpr -> throw AssemblyError("range expression should have been changed into array values")
        }
    }

    private fun translateExpression(expr: AddressOf) {
        val name = asmIdentifierName(expr.identifier)
        out("  lda  #<$name |  sta  $ESTACK_LO_HEX,x |  lda  #>$name  |  sta  $ESTACK_HI_HEX,x  | dex")
    }

    private fun translateExpression(expr: DirectMemoryRead) {
        when(expr.addressExpression) {
            is NumericLiteralValue -> {
                val address = (expr.addressExpression as NumericLiteralValue).number.toInt()
                out("  lda  ${address.toHex()} |  sta  $ESTACK_LO_HEX,x |  dex")
            }
            is IdentifierReference -> {
                val sourceName = asmIdentifierName(expr.addressExpression as IdentifierReference)
                out("  lda  $sourceName |  sta  $ESTACK_LO_HEX,x |  dex")
            }
            else -> {
                translateExpression(expr.addressExpression)
                out("  jsr  prog8_lib.read_byte_from_address")
                out("  sta  $ESTACK_LO_PLUS1_HEX,x")
            }
        }
    }

    private fun translateExpression(expr: NumericLiteralValue) {
        when(expr.type) {
            DataType.UBYTE, DataType.BYTE -> out(" lda  #${expr.number.toHex()}  | sta  $ESTACK_LO_HEX,x  | dex")
            DataType.UWORD, DataType.WORD -> out("""
                lda  #<${expr.number.toHex()}
                sta  $ESTACK_LO_HEX,x
                lda  #>${expr.number.toHex()}
                sta  $ESTACK_HI_HEX,x
                dex
            """)
            DataType.FLOAT -> {
                val floatConst = getFloatConst(expr.number.toDouble())
                out(" lda  #<$floatConst |  ldy  #>$floatConst |  jsr  c64flt.push_float")
            }
            else -> throw AssemblyError("weird type")
        }
    }

    private fun translateExpression(expr: RegisterExpr) {
        when(expr.register) {
            Register.A -> out(" sta  $ESTACK_LO_HEX,x | dex")
            Register.X -> throw AssemblyError("cannot push X - use a variable instead of the X register")
            Register.Y -> out(" tya |  sta  $ESTACK_LO_HEX,x | dex")
        }
    }

    private fun translateExpression(expr: IdentifierReference) {
        val varname = asmIdentifierName(expr)
        when(expr.inferType(program)!!) {
            DataType.UBYTE, DataType.BYTE -> {
                out("  lda  $varname  |  sta  $ESTACK_LO_HEX,x  |  dex")
            }
            DataType.UWORD, DataType.WORD, in ArrayDatatypes, in StringDatatypes -> {
                // (for arrays and strings, push their address)
                out("  lda  $varname  |  sta  $ESTACK_LO_HEX,x  |  lda  $varname+1 |  sta  $ESTACK_HI_HEX,x |  dex")
            }
            DataType.FLOAT -> {
                out(" lda  #<$varname |  ldy  #>$varname|  jsr  c64flt.push_float")
            }
            else -> throw AssemblyError("stack push weird variable type $expr")
        }
    }

    private fun translateExpression(expr: BinaryExpression) {
        translateExpression(expr.left)
        translateExpression(expr.right)
        val leftDt = expr.left.inferType(program)!!
        val rightDt = expr.right.inferType(program)!!
        if(leftDt!=rightDt)
            throw AssemblyError("binary operator ${expr.operator} left/right dt not identical")     // is this strictly required always?
        when (leftDt) {
            in ByteDatatypes -> translateBinaryOperatorBytes(expr.operator, leftDt)
            in WordDatatypes -> translateBinaryOperatorWords(expr.operator, leftDt)
            DataType.FLOAT -> translateBinaryOperatorFloats(expr.operator)
            else -> throw AssemblyError("non-numerical datatype")
        }
    }

    private fun translateExpression(expr: PrefixExpression) {
        translateExpression(expr.expression)
        val type = expr.inferType(program)
        when(expr.operator) {
            "+" -> {}
            "-" -> {
                when(type) {
                    in ByteDatatypes -> out("  jsr  prog8_lib.neg_b")
                    in WordDatatypes -> out("  jsr  prog8_lib.neg_w")
                    DataType.FLOAT -> out("  jsr  c64flt.neg_f")
                    else -> throw AssemblyError("weird type")
                }
            }
            "~" -> {
                when(type) {
                    in ByteDatatypes ->
                        out("""
                            lda  $ESTACK_LO_PLUS1_HEX,x
                            eor  #255
                            sta  $ESTACK_LO_PLUS1_HEX,x
                            """)
                    in WordDatatypes -> out("  jsr  prog8_lib.inv_word")
                    else -> throw AssemblyError("weird type")
                }
            }
            "not" -> {
                when(type) {
                    in ByteDatatypes -> out("  jsr  prog8_lib.not_byte")
                    in WordDatatypes -> out("  jsr  prog8_lib.not_word")
                    else -> throw AssemblyError("weird type")
                }
            }
            else -> throw AssemblyError("invalid prefix operator ${expr.operator}")
        }
    }

    private fun translateBinaryOperatorBytes(operator: String, types: DataType) {
        when(operator) {
            "**" -> throw AssemblyError("** operator requires floats")
            "*" -> out("  jsr  prog8_lib.mul_byte")
            "/" -> out(if(types==DataType.UBYTE) "  jsr  prog8_lib.idiv_ub" else "  jsr  prog8_lib.idiv_b")
            "%" -> {
                if(types==DataType.BYTE)
                    throw AssemblyError("remainder of signed integers is not properly defined/implemented, use unsigned instead")
                out("  jsr prog8_lib.remainder_ub")
            }
            "+" -> out("  jsr  prog8_lib.add_w")
            "-" -> out("  jsr  prog8_lib.sub_w")
            "<<" -> throw AssemblyError("<< should not operate via stack")
            ">>" -> throw AssemblyError(">> should not operate via stack")
            "<" -> out(if(types==DataType.UBYTE) "  jsr  prog8_lib.less_ub" else "  jsr  prog8_lib.less_b")
            ">" -> out(if(types==DataType.UBYTE) "  jsr  prog8_lib.greater_ub" else "  jsr  prog8_lib.greater_b")
            "<=" -> out(if(types==DataType.UBYTE) "  jsr  prog8_lib.lesseq_ub" else "  jsr  prog8_lib.lesseq_b")
            ">=" -> out(if(types==DataType.UBYTE) "  jsr  prog8_lib.greatereq_ub" else "  jsr  prog8_lib.greatereq_b")
            "==" -> out("  jsr  prog8_lib.equal_b")
            "!=" -> out("  jsr  prog8_lib.notequal_b")
            "&" -> out("  jsr  prog8_lib.bitand_b")
            "^" -> out("  jsr  prog8_lib.bitxor_b")
            "|" -> out("  jsr  prog8_lib.bitor_b")
            "and" -> out("  jsr  prog8_lib.and_b")
            "or" -> out("  jsr  prog8_lib.or_b")
            "xor" -> out("  jsr  prog8_lib.xor_b")
            else -> throw AssemblyError("invalid operator $operator")
        }
    }

    private fun translateBinaryOperatorWords(operator: String, types: DataType) {
        when(operator) {
            "**" -> throw AssemblyError("** operator requires floats")
            "*" -> out("  jsr  prog8_lib.mul_word")
            "/" -> out(if(types==DataType.UWORD) "  jsr  prog8_lib.idiv_uw" else "  jsr  prog8_lib.idiv_w")
            "%" -> {
                if(types==DataType.WORD)
                    throw AssemblyError("remainder of signed integers is not properly defined/implemented, use unsigned instead")
                out("  jsr prog8_lib.remainder_uw")
            }
            "+" -> out("""
                lda  $ESTACK_LO_PLUS2_HEX,x
                clc
                adc  $ESTACK_LO_PLUS1_HEX,x
                inx
                sta  $ESTACK_LO_PLUS1_HEX,x
                """)
            "-" -> out("""
                lda  $ESTACK_LO_PLUS2_HEX,x
                sec
                sbc  $ESTACK_LO_PLUS1_HEX,x
                inx
                sta  $ESTACK_LO_PLUS1_HEX,x
                """)
            "<<" -> throw AssemblyError("<< should not operate via stack")
            ">>" -> throw AssemblyError(">> should not operate via stack")
            "<" -> out(if(types==DataType.UWORD) "  jsr  prog8_lib.less_uw" else "  jsr  prog8_lib.less_w")
            ">" -> out(if(types==DataType.UWORD) "  jsr  prog8_lib.greater_uw" else "  jsr  prog8_lib.greater_w")
            "<=" -> out(if(types==DataType.UWORD) "  jsr  prog8_lib.lesseq_uw" else "  jsr  prog8_lib.lesseq_w")
            ">=" -> out(if(types==DataType.UWORD) "  jsr  prog8_lib.greatereq_uw" else "  jsr  prog8_lib.greatereq_w")
            "==" -> out("  jsr  prog8_lib.equal_w")
            "!=" -> out("  jsr  prog8_lib.notequal_w")
            "&" -> out("  jsr  prog8_lib.bitand_w")
            "^" -> out("  jsr  prog8_lib.bitxor_w")
            "|" -> out("  jsr  prog8_lib.bitor_w")
            "and" -> out("  jsr  prog8_lib.and_w")
            "or" -> out("  jsr  prog8_lib.or_w")
            "xor" -> out("  jsr  prog8_lib.xor_w")
            else -> throw AssemblyError("invalid operator $operator")
        }
    }

    private fun translateBinaryOperatorFloats(operator: String) {
        when(operator) {
            "**" -> out(" jsr  c64flt.pow_f")
            "*" -> out("  jsr  c64flt.mul_f")
            "/" -> out("  jsr  c64flt.div_f")
            "+" -> out("  jsr  c64flt.add_f")
            "-" -> out("  jsr  c64flt.sub_f")
            "<" -> out("  jsr  c64flt.less_f")
            ">" -> out("  jsr  c64flt.greater_f")
            "<=" -> out("  jsr  c64flt.lesseq_f")
            ">=" -> out("  jsr  c64flt.greatereq_f")
            "==" -> out("  jsr  c64flt.equal_f")
            "!=" -> out("  jsr  c64flt.notequal_f")
            "%", "<<", ">>", "&", "^", "|", "and", "or", "xor" -> throw AssemblyError("requires integer datatype")
            else -> throw AssemblyError("invalid operator $operator")
        }
    }

    private fun assignFromEvalResult(target: AssignTarget) {
        val targetIdent = target.identifier
        when {
            target.register!=null -> {
                if(target.register==Register.X)
                    throw AssemblyError("can't pop into X register - use variable instead")
                out(" inx | ld${target.register.name.toLowerCase()}  $ESTACK_LO_HEX,x ")
            }
            targetIdent!=null -> {
                val targetName = asmIdentifierName(targetIdent)
                val targetDt = targetIdent.inferType(program)!!
                when(targetDt) {
                    DataType.UBYTE, DataType.BYTE -> {
                        out(" inx | lda  $ESTACK_LO_HEX,x  | sta  $targetName")
                    }
                    DataType.UWORD, DataType.WORD -> {
                        out("""
                            inx
                            lda  $ESTACK_LO_HEX,x
                            sta  $targetName
                            lda  $ESTACK_HI_HEX,x
                            sta  $targetName+1
                        """)
                    }
                    DataType.FLOAT -> {
                        out("""
                            lda  #<$targetName
                            ldy  #>$targetName
                            jsr  c64flt.pop_float
                        """)
                    }
                    else -> throw AssemblyError("weird target variable type $targetDt")
                }
            }
            target.memoryAddress!=null -> {
                out("  inx  | ldy  $ESTACK_LO_HEX,x")
                storeRegisterInMemoryAddress(Register.Y, target.memoryAddress)
            }
            target.arrayindexed!=null -> {
                TODO("put result in arrayindexed $target")
            }
            else -> throw AssemblyError("weird assignment target $target")
        }
    }

    private fun assignFromAddressOf(target: AssignTarget, name: IdentifierReference, scopedname: String) {
        val targetIdent = target.identifier
        val targetArrayIdx = target.arrayindexed
        val struct = name.memberOfStruct(program.namespace)
        val sourceName = if(struct!=null) {
            // take the address of the first struct member instead
            val decl = name.targetVarDecl(program.namespace)!!
            val firstStructMember = struct.nameOfFirstMember()
            // find the flattened var that belongs to this first struct member
            val firstVarName = listOf(decl.name, firstStructMember)
            val firstVar = name.definingScope().lookup(firstVarName, name) as VarDecl
            firstVar.name
        } else {
            fixNameSymbols(scopedname)
        }
        when {
            targetIdent!=null -> {
                val targetName = asmIdentifierName(targetIdent)
                out("""
                        lda  #<$sourceName
                        ldy  #>$sourceName
                        sta  $targetName
                        sty  $targetName+1
                    """)
            }
            target.memoryAddress!=null -> {
                TODO("assign address $sourceName to memory word $target")
            }
            targetArrayIdx!=null -> {
                val index = targetArrayIdx.arrayspec.index
                val targetName = asmIdentifierName(targetArrayIdx.identifier)
                TODO("assign address $sourceName to array $targetName [ $index ]")
            }
            else -> TODO("assign address $sourceName to $target")
        }
    }

    private fun assignFromWordVariable(target: AssignTarget, variable: IdentifierReference) {
        val sourceName = asmIdentifierName(variable)
        val targetIdent = target.identifier
        val targetArrayIdx = target.arrayindexed
        when {
            targetIdent!=null -> {
                val targetName = asmIdentifierName(targetIdent)
                out("""
                    lda  $sourceName
                    ldy  $sourceName+1
                    sta  $targetName
                    sty  $targetName+1
                """)
            }
            target.memoryAddress!=null -> {
                TODO("assign wordvar $sourceName to memory ${target.memoryAddress}")
            }
            targetArrayIdx!=null -> {
                val index = targetArrayIdx.arrayspec.index
                val targetName = asmIdentifierName(targetArrayIdx.identifier)
                TODO("assign wordvar $sourceName to array $targetName [ $index ]")
            }
            else -> TODO("assign wordvar to $target")
        }
    }

    private fun assignFromFloatVariable(target: AssignTarget, variable: IdentifierReference) {
        val sourceName = asmIdentifierName(variable)
        val targetIdent = target.identifier
        val targetArrayIdx = target.arrayindexed
        when {
            targetIdent!=null -> {
                val targetName = asmIdentifierName(targetIdent)
                out("""
                    lda  $sourceName
                    sta  $targetName
                    lda  $sourceName+1
                    sta  $targetName+1
                    lda  $sourceName+2
                    sta  $targetName+2
                    lda  $sourceName+3
                    sta  $targetName+3
                    lda  $sourceName+4
                    sta  $targetName+4
                """)
            }
            target.memoryAddress!=null -> {
                TODO("assign floatvar $sourceName to memory ${target.memoryAddress}")
            }
            targetArrayIdx!=null -> {
                val index = targetArrayIdx.arrayspec.index
                val targetName = asmIdentifierName(targetArrayIdx.identifier)
                TODO("assign floatvar $sourceName to array $targetName [ $index ]")
            }
            else -> TODO("assign floatvar to $target")
        }
    }

    private fun assignFromByteVariable(target: AssignTarget, variable: IdentifierReference) {
        val sourceName = asmIdentifierName(variable)
        val targetIdent = target.identifier
        val targetArrayIdx = target.arrayindexed
        when {
            target.register!=null -> {
                out("  ld${target.register.name.toLowerCase()}  $sourceName")
            }
            targetIdent!=null -> {
                val targetName = asmIdentifierName(targetIdent)
                out("""
                    lda  $sourceName
                    sta  $targetName
                    """)
            }
            targetArrayIdx!=null -> {
                val index = targetArrayIdx.arrayspec.index
                val targetName = asmIdentifierName(targetArrayIdx.identifier)
                TODO("assign bytevar to array $targetName [ $index ] ")
            }
            target.memoryAddress != null -> {
                val addressExpr = target.memoryAddress.addressExpression
                val addressLv = addressExpr as? NumericLiteralValue
                when {
                    addressLv != null -> out("  lda  $sourceName |  sta  ${addressLv.number.toHex()}")
                    addressExpr is IdentifierReference -> {
                        val targetName = asmIdentifierName(addressExpr)
                        out("  lda  $sourceName |  sta  $targetName")
                    }
                    else -> {
                        translateExpression(addressExpr)
                        out("""
     inx
     lda  $ESTACK_LO_HEX,x
     ldy  $ESTACK_HI_HEX,x
     sta  (+) +1
     sty  (+) +2
     lda  $sourceName
+    sta  ${65535.toHex()}      ; modified              
                            """)
                    }
                }
            }
            else -> TODO("assign bytevar to $target")
        }
    }

    private fun assignFromRegister(target: AssignTarget, register: Register) {
        val targetIdent = target.identifier
        val targetArrayIdx = target.arrayindexed
        when {
            targetIdent!=null -> {
                val targetName = asmIdentifierName(targetIdent)
                out("  st${register.name.toLowerCase()}  $targetName")
            }
            target.register!=null -> {
                when(register) {
                    Register.A -> when(target.register) {
                        Register.A -> {}
                        Register.X -> out("  tax")
                        Register.Y -> out("  tay")
                    }
                    Register.X -> when(target.register) {
                        Register.A -> out("  txa")
                        Register.X -> {}
                        Register.Y -> out("  txy")
                    }
                    Register.Y -> when(target.register) {
                        Register.A -> out("  tya")
                        Register.X -> out("  tyx")
                        Register.Y -> {}
                    }
                }
            }
            target.memoryAddress!=null -> {
                storeRegisterInMemoryAddress(register, target.memoryAddress)
            }
            targetArrayIdx!=null -> {
                val index = targetArrayIdx.arrayspec.index
                val targetName = asmIdentifierName(targetArrayIdx.identifier)
                when (index) {
                    is NumericLiteralValue -> {
                        val memindex = index.number.toInt()
                        when(register) {
                            Register.A -> out("  sta  $targetName+$memindex")
                            Register.X -> out("  stx  $targetName+$memindex")
                            Register.Y -> out("  sty  $targetName+$memindex")
                        }
                    }
                    is RegisterExpr -> {
                        when(register) {
                            Register.A -> out("  sta  ${C64Zeropage.SCRATCH_B1}")
                            Register.X -> out("  stx  ${C64Zeropage.SCRATCH_B1}")
                            Register.Y -> out("  sty  ${C64Zeropage.SCRATCH_B1}")
                        }
                        when(index.register) {
                            Register.A -> {}
                            Register.X -> out("  txa")
                            Register.Y -> out("  tya")
                        }
                        out("""
                            tay
                            lda  ${C64Zeropage.SCRATCH_B1}
                            sta  $targetName,y
                            """)
                    }
                    is IdentifierReference -> {
                        when(register) {
                            Register.A -> out("  sta  ${C64Zeropage.SCRATCH_B1}")
                            Register.X -> out("  stx  ${C64Zeropage.SCRATCH_B1}")
                            Register.Y -> out("  sty  ${C64Zeropage.SCRATCH_B1}")
                        }
                        out("""
                            lda  ${asmIdentifierName(index)}
                            tay
                            lda  ${C64Zeropage.SCRATCH_B1}
                            sta  $targetName,y
                        """)
                    }
                    else -> {
                        saveRegister(register)
                        translateExpression(index)
                        restoreRegister(register)
                        when(register) {
                            Register.A -> out("  sta  ${C64Zeropage.SCRATCH_B1}")
                            Register.X -> out("  stx  ${C64Zeropage.SCRATCH_B1}")
                            Register.Y -> out("  sty  ${C64Zeropage.SCRATCH_B1}")
                        }
                        out("""
                            inx
                            lda  $ESTACK_LO_HEX,x
                            tay
                            lda  ${C64Zeropage.SCRATCH_B1}
                            sta  $targetName,y  
                        """)
                    }
                }
            }
            else -> TODO("assign register $register to $target")
        }
    }

    private fun storeRegisterInMemoryAddress(register: Register, memoryAddress: DirectMemoryWrite) {
        val addressExpr = memoryAddress.addressExpression
        val addressLv = addressExpr as? NumericLiteralValue
        val registerName = register.name.toLowerCase()
        when {
            addressLv != null -> out("  st$registerName  ${addressLv.number.toHex()}")
            addressExpr is IdentifierReference -> {
                val targetName = asmIdentifierName(addressExpr)
                out("  st$registerName  $targetName")
            }
            else -> {
                saveRegister(register)
                translateExpression(addressExpr)
                restoreRegister(register)
                when (register) {
                    Register.A -> out("  tay")
                    Register.X -> throw AssemblyError("can't use X register here")
                    Register.Y -> {}
                }
                out("""
     inx
     lda  $ESTACK_LO_HEX,x
     sta  (+) +1
     lda  $ESTACK_HI_HEX,x
     sta  (+) +2
+    sty  ${65535.toHex()}      ; modified              
                            """)
            }
        }
    }

    private fun assignFromWordConstant(target: AssignTarget, word: Int) {
        val targetIdent = target.identifier
        val targetArrayIdx = target.arrayindexed
        when {
            targetIdent!=null -> {
                val targetName = asmIdentifierName(targetIdent)
                if(word ushr 8 == word and 255) {
                    // lsb=msb
                    out("""
                    lda  #${(word and 255).toHex()}
                    sta  $targetName
                    sta  $targetName+1
                """)
                } else {
                    out("""
                    lda  #<${word.toHex()}
                    ldy  #>${word.toHex()}
                    sta  $targetName
                    sty  $targetName+1
                """)
                }
            }
            target.memoryAddress!=null -> {
                TODO("assign word $word to memory ${target.memoryAddress}")
            }
            targetArrayIdx!=null -> {
                val index = targetArrayIdx.arrayspec.index
                val targetName = asmIdentifierName(targetArrayIdx.identifier)
                TODO("assign word $word to array $targetName [ $index ]")
            }
            else -> TODO("assign word $word to $target")
        }
    }

    private fun assignFromByteConstant(target: AssignTarget, byte: Short) {
        val targetIdent = target.identifier
        val targetArrayIdx = target.arrayindexed
        when {
            target.register!=null -> {
                out("  ld${target.register.name.toLowerCase()}  #${byte.toHex()}")
            }
            targetIdent!=null -> {
                val targetName = asmIdentifierName(targetIdent)
                out(" lda  #${byte.toHex()} |  sta  $targetName ")
            }
            target.memoryAddress!=null -> {
                out("  ldy  #${byte.toHex()}")
                storeRegisterInMemoryAddress(Register.Y, target.memoryAddress)
            }
            targetArrayIdx!=null -> {
                val index = targetArrayIdx.arrayspec.index
                val targetName = asmIdentifierName(targetArrayIdx.identifier)
                TODO("assign byte $byte to array $targetName [ $index ]")
            }
            else -> TODO("assign byte $byte to $target")
        }
    }

    private fun assignFromFloatConstant(target: AssignTarget, float: Double) {
        val targetIdent = target.identifier
        val targetArrayIdx = target.arrayindexed
        if(float==0.0) {
            // optimized case for float zero
            when {
                targetIdent != null -> {
                    val targetName = asmIdentifierName(targetIdent)
                    out("""
                            lda  #0
                            sta  $targetName
                            sta  $targetName+1
                            sta  $targetName+2
                            sta  $targetName+3
                            sta  $targetName+4
                        """)
                }
                target.memoryAddress!=null -> {
                    TODO("assign float 0.0 to memory ${target.memoryAddress}")
                }
                targetArrayIdx!=null -> {
                    val index = targetArrayIdx.arrayspec.index
                    val targetName = asmIdentifierName(targetArrayIdx.identifier)
                    TODO("assign float 0.0 to array $targetName [ $index ]")
                }
                else -> TODO("assign float 0.0 to $target")
            }
        } else {
            // non-zero value
            val constFloat = getFloatConst(float)
            if (targetIdent != null) {
                val targetName = asmIdentifierName(targetIdent)
                out("""
                        lda  $constFloat
                        sta  $targetName
                        lda  $constFloat+1
                        sta  $targetName+1
                        lda  $constFloat+2
                        sta  $targetName+2
                        lda  $constFloat+3
                        sta  $targetName+3
                        lda  $constFloat+4
                        sta  $targetName+4
                    """)
            } else {
                TODO("assign float $float ($constFloat) to $target")
            }
        }
    }

    private fun assignFromMemoryByte(target: AssignTarget, address: Int?, identifier: IdentifierReference?) {
        val targetIdent = target.identifier
        val targetArrayIdx = target.arrayindexed
        if(address!=null) {
            when {
                target.register!=null -> {
                    out("  ld${target.register.name.toLowerCase()}  ${address.toHex()}")
                }
                targetIdent!=null -> {
                    val targetName = asmIdentifierName(targetIdent)
                    out("""
                        lda  ${address.toHex()}
                        sta  $targetName
                        """)
                }
                target.memoryAddress!=null -> {
                    out("  ldy  ${address.toHex()}")
                    storeRegisterInMemoryAddress(Register.Y, target.memoryAddress)
                }
                targetArrayIdx!=null -> {
                    val index = targetArrayIdx.arrayspec.index
                    val targetName = asmIdentifierName(targetArrayIdx.identifier)
                    TODO("assign memory byte at $address to array $targetName [ $index ]")
                }
                else -> TODO("assign memory byte $target")
            }
        }
        else if(identifier!=null) {
            val sourceName = asmIdentifierName(identifier)
            when {
                target.register!=null -> {
                    out("""
                        ldy  #0
                        lda  ($sourceName),y
                    """)
                    when(target.register){
                        Register.A -> {}
                        Register.X -> out("  tax")
                        Register.Y -> out("  tay")
                    }
                }
                targetIdent!=null -> {
                    val targetName = asmIdentifierName(targetIdent)
                    out("""
                        ldy  #0
                        lda  ($sourceName),y
                        sta  $targetName
                    """)
                }
                target.memoryAddress!=null -> {
                    out("  ldy  $sourceName")
                    storeRegisterInMemoryAddress(Register.Y, target.memoryAddress)
                }
                targetArrayIdx!=null -> {
                    val index = targetArrayIdx.arrayspec.index
                    val targetName = asmIdentifierName(targetArrayIdx.identifier)
                    TODO("assign memory byte $sourceName to array $targetName [ $index ]")
                }
                else -> TODO("assign memory byte $target")
            }
        }
    }
}
