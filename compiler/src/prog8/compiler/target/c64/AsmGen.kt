package prog8.compiler.target.c64

// note: to put stuff on the stack, we use Absolute,X  addressing mode which is 3 bytes / 4 cycles
// possible space optimization is to use zeropage (indirect),Y  which is 2 bytes, but 5 cycles


import prog8.ast.DataType
import prog8.ast.Register
import prog8.compiler.*
import prog8.compiler.intermediate.*
import prog8.stackvm.syscallsForStackVm
import java.io.File
import java.io.PrintWriter
import java.util.*
import kotlin.math.abs


private val registerStrings = Register.values().map{it.toString()}.toSet()

class AssemblyError(msg: String) : RuntimeException(msg)


class AsmGen(val options: CompilationOptions, val program: IntermediateProgram, val heap: HeapValues) {
    private val globalFloatConsts = mutableMapOf<Double, String>()
    private lateinit var output: PrintWriter
    private lateinit var block: IntermediateProgram.ProgramBlock
    private var breakpointCounter = 0

    init {
        // Because 64tass understands scoped names via .proc / .block,
        // we'll strip the block prefix from all scoped names in the program.
        // Also, convert invalid label names (such as "<<<anonymous-1>>>") to something that's allowed.
        val newblocks = mutableListOf<IntermediateProgram.ProgramBlock>()
        for(block in program.blocks) {
            val newvars = block.variables.map { symname(it.key, block) to it.value }.toMap().toMutableMap()
            val newlabels = block.labels.map { symname(it.key, block) to it.value}.toMap().toMutableMap()
            val newinstructions = block.instructions.asSequence().map {
                when {
                    it is LabelInstr -> LabelInstr(symname(it.name, block))
                    it.opcode == Opcode.INLINE_ASSEMBLY -> it
                    else -> Instruction(it.opcode, it.arg,
                            if (it.callLabel != null) symname(it.callLabel, block) else null,
                            if (it.callLabel2 != null) symname(it.callLabel2, block) else null)
                }
            }.toMutableList()
            val newConstants = block.integerConstants.map { symname(it.key, block) to it.value }.toMap().toMutableMap()
            newblocks.add(IntermediateProgram.ProgramBlock(
                    block.scopedname,
                    block.shortname,
                    block.address,
                    newinstructions,
                    newvars,
                    newConstants,
                    newlabels))
        }
        program.blocks.clear()
        program.blocks.addAll(newblocks)

        // make a list of all const floats that are used
        for(block in program.blocks) {
            for(ins in block.instructions.filter{it.arg?.type==DataType.FLOAT}) {
                val float = ins.arg!!.numericValue().toDouble()
                if(float !in globalFloatConsts)
                    globalFloatConsts[float] = "prog8_const_float_${globalFloatConsts.size}"
            }
        }
    }

    private fun out(str: String?) = output.println(str)

    fun compileToAssembly(): AssemblyProgram {
        println("\nGenerating assembly code from intermediate code... ")

        // todo generate 6502 assembly
        output = File("${program.name}.asm").printWriter()
        output.use {
            header()
            for(b in program.blocks)
                block2asm(b)
        }

        return AssemblyProgram(program.name)
    }

    private fun symname(scoped: String, block: IntermediateProgram.ProgramBlock): String {
        if(' ' in scoped)
            return scoped

        val blockLocal: Boolean
        var name = if (scoped.startsWith("${block.shortname}.")) {
            blockLocal = true
            scoped.substring(block.shortname.length+1)
        } else {
            blockLocal = false
            scoped
        }
        name = name.replace("<<<", "prog8_").replace(">>>", "")
        if(name=="-")
            return "-"
        if(blockLocal)
            name = name.replace(".", "_")
        else {
            val parts = name.split(".", limit=2)
            if(parts.size>1)
                name = "${parts[0]}.${parts[1].replace(".", "_")}"
        }
        return name.replace("-", "")
    }

    private fun makeFloatFill(flt: Mflpt5): String {
        val b0 = "$"+flt.b0.toString(16).padStart(2, '0')
        val b1 = "$"+flt.b1.toString(16).padStart(2, '0')
        val b2 = "$"+flt.b2.toString(16).padStart(2, '0')
        val b3 = "$"+flt.b3.toString(16).padStart(2, '0')
        val b4 = "$"+flt.b4.toString(16).padStart(2, '0')
        return "$b0, $b1, $b2, $b3, $b4"
    }

    private fun header() {
        val ourName = this.javaClass.name
        out("; 6502 assembly code for '${program.name}'")
        out("; generated by $ourName on ${Date()}")
        out("; assembler syntax is for the 64tasm cross-assembler")
        out("; output options: output=${options.output} launcher=${options.launcher} zp=${options.zeropage}")
        out("\n.cpu  '6502'\n.enc  'none'\n")

        if(program.loadAddress==0)   // fix load address
            program.loadAddress = if(options.launcher==LauncherType.BASIC) BASIC_LOAD_ADDRESS else RAW_LOAD_ADDRESS

        when {
            options.launcher == LauncherType.BASIC -> {
                if (program.loadAddress != 0x0801)
                    throw AssemblyError("BASIC output must have load address $0801")
                out("; ---- basic program with sys call ----")
                out("* = ${program.loadAddress.toHex()}")
                val year = Calendar.getInstance().get(Calendar.YEAR)
                out("\t.word  (+), $year")
                out("\t.null  $9e, format(' %d ', _prog8_entrypoint), $3a, $8f, ' prog8 by idj'")
                out("+\t.word  0")
                out("_prog8_entrypoint\t; assembly code starts here\n")
                out("\tjsr  c64utils.init_system")
            }
            options.output == OutputType.PRG -> {
                out("; ---- program without sys call ----")
                out("* = ${program.loadAddress.toHex()}\n")
                out("\tjsr  c64utils.init_system")
            }
            options.output == OutputType.RAW -> {
                out("; ---- raw assembler program ----")
                out("* = ${program.loadAddress.toHex()}\n")
            }
        }

        out("\tldx  #\$ff\t; init estack pointer")
        out("\tclc")
        out("\tjmp  main.start\t; jump to program entrypoint")
        out("")

        // the global list of all floating point constants for the whole program
        for(flt in globalFloatConsts) {
            val floatFill = makeFloatFill(Mflpt5.fromNumber(flt.key))
            out("${flt.value}\t.byte  $floatFill  ; float ${flt.key}")
        }
    }

    private fun block2asm(blk: IntermediateProgram.ProgramBlock) {
        block = blk
        out("\n; ---- block: '${block.shortname}' ----")
        if(block.address!=null) {
            out(".cerror * > ${block.address?.toHex()}, 'block address overlaps by ', *-${block.address?.toHex()},' bytes'")
            out("* = ${block.address?.toHex()}")
        }
        out("${block.shortname}\t.proc\n")
        out("\n; constants/memdefs/kernel subroutines")
        memdefs2asm(block)
        out("\n; variables")
        vardecls2asm(block)
        out("")

        val instructionPatternWindowSize = 6
        var processed = 0
        for(ins in block.instructions.windowed(instructionPatternWindowSize, partialWindows = true)) {
            if(processed==0) {
                processed = instr2asm(ins)
                if(processed == 0)
                    throw CompilerException("no asm translation found for instruction pattern: $ins")
            }
            processed--
        }
        out("\n\t.pend\n")
    }

    private fun memdefs2asm(block: IntermediateProgram.ProgramBlock) {
        for(m in block.integerConstants) {
            out("\t${m.key} = ${m.value.toHex()}")
        }
    }

    private fun vardecls2asm(block: IntermediateProgram.ProgramBlock) {
        val sortedVars = block.variables.toList().sortedBy { it.second.type }
        for (v in sortedVars) {
            when (v.second.type) {
                DataType.UBYTE -> out("${v.first}\t.byte  0")
                DataType.BYTE -> out("${v.first}\t.char  0")
                DataType.UWORD -> out("${v.first}\t.word  0")
                DataType.WORD -> out("${v.first}\t.sint  0")
                DataType.FLOAT -> out("${v.first}\t.fill  5  ; float")
                DataType.STR,
                DataType.STR_P,
                DataType.STR_S,
                DataType.STR_PS -> {
                    val rawStr = heap.get(v.second.heapId).str!!
                    val bytes = encodeStr(rawStr, v.second.type).map { "$" + it.toString(16).padStart(2, '0') }
                    out("${v.first}\t; ${v.second.type} \"$rawStr\"")
                    for (chunk in bytes.chunked(16))
                        out("\t.byte  " + chunk.joinToString())
                }
                DataType.ARRAY_UB, DataType.MATRIX_UB -> {
                    // unsigned integer byte array
                    val data = makeArrayFillDataUnsigned(v.second)
                    if (data.size <= 16)
                        out("${v.first}\t.byte  ${data.joinToString()}")
                    else {
                        out(v.first)
                        for (chunk in data.chunked(16))
                            out("\t.byte  " + chunk.joinToString())
                    }
                }
                DataType.ARRAY_B, DataType.MATRIX_B -> {
                    // signed integer byte array
                    val data = makeArrayFillDataSigned(v.second)
                    if (data.size <= 16)
                        out("${v.first}\t.char  ${data.joinToString()}")
                    else {
                        out(v.first)
                        for (chunk in data.chunked(16))
                            out("\t.char  " + chunk.joinToString())
                    }
                }
                DataType.ARRAY_UW -> {
                    // unsigned word array
                    val data = makeArrayFillDataUnsigned(v.second)
                    if (data.size <= 16)
                        out("${v.first}\t.word  ${data.joinToString()}")
                    else {
                        out(v.first)
                        for (chunk in data.chunked(16))
                            out("\t.word  " + chunk.joinToString())
                    }
                }
                DataType.ARRAY_W -> {
                    // signed word array
                    val data = makeArrayFillDataSigned(v.second)
                    if (data.size <= 16)
                        out("${v.first}\t.sint  ${data.joinToString()}")
                    else {
                        out(v.first)
                        for (chunk in data.chunked(16))
                            out("\t.sint  " + chunk.joinToString())
                    }
                }
                DataType.ARRAY_F -> {
                    // float array
                    val array = heap.get(v.second.heapId).doubleArray!!
                    val floatFills = array.map { makeFloatFill(Mflpt5.fromNumber(it)) }
                    out(v.first)
                    for(f in array.zip(floatFills))
                        out("\t.byte  ${f.second}  ; float ${f.first}")
                }
            }
        }
    }

    private fun encodeStr(str: String, dt: DataType): List<Short> {
        when(dt) {
            DataType.STR -> {
                val bytes = Petscii.encodePetscii(str, true)
                return bytes.plus(0)
            }
            DataType.STR_P -> {
                val result = listOf(str.length.toShort())
                val bytes = Petscii.encodePetscii(str, true)
                return result.plus(bytes)
            }
            DataType.STR_S -> {
                val bytes = Petscii.encodeScreencode(str, true)
                return bytes.plus(0)
            }
            DataType.STR_PS -> {
                val result = listOf(str.length.toShort())
                val bytes = Petscii.encodeScreencode(str, true)
                return result.plus(bytes)
            }
            else -> throw AssemblyError("invalid str type")
        }
    }

    private fun makeArrayFillDataUnsigned(value: Value): List<String> {
        val array = heap.get(value.heapId).array!!
        return if (value.type == DataType.ARRAY_UB || value.type == DataType.ARRAY_UW || value.type == DataType.MATRIX_UB)
            array.map { "$"+it.toString(16).padStart(2, '0') }
        else
            throw AssemblyError("invalid array type")
    }

    private fun makeArrayFillDataSigned(value: Value): List<String> {
        val array = heap.get(value.heapId).array!!
        return if (value.type == DataType.ARRAY_B || value.type == DataType.ARRAY_W || value.type == DataType.MATRIX_B) {
            array.map {
                if(it>=0)
                    "$"+it.toString(16).padStart(2, '0')
                else
                    "-$"+abs(it).toString(16).padStart(2, '0')
            }
        }
        else throw AssemblyError("invalid array type")
    }

    private fun instr2asm(ins: List<Instruction>): Int {
        // find best patterns (matching the most of the lines, then with the smallest weight)
        val fragments = findPatterns(ins).sortedWith(compareBy({it.segmentSize}, {it.prio}))
        if(fragments.isEmpty()) {
            // we didn't find any matching patterns (complex multi-instruction fragments), try simple ones
            val firstIns = ins[0]
            val singleAsm = simpleInstr2Asm(firstIns)
            if(singleAsm != null) {
                outputAsmFragment(singleAsm)
                return 1
            }
            return 0
        }
        val best = fragments[0]
        outputAsmFragment(best.asm)
        return best.segmentSize
    }

    private fun outputAsmFragment(singleAsm: String) {
        if (singleAsm.isNotEmpty()) {
            when {
                singleAsm.startsWith("@inline@") -> out(singleAsm.substring(8))
                '\n' in singleAsm -> for (line in singleAsm.split('\n')) {
                    if (line.isNotEmpty()) {
                        val trimmed = if (line.startsWith(' ')) "\t" + line.trim() else line.trim()
                        out(trimmed)
                    }
                }
                else -> for (line in singleAsm.split('|')) {
                    val trimmed = if (line.startsWith(' ')) "\t" + line.trim() else line.trim()
                    out(trimmed)
                }
            }
        }
    }

    private fun simpleInstr2Asm(ins: Instruction): String? {
        // a label 'instruction' is simply translated into a asm label
        if(ins is LabelInstr) {
            if(ins.name==block.shortname)
                return ""
            return if(ins.name.startsWith("${block.shortname}."))
                ins.name.substring(block.shortname.length+1)
            else
                ins.name
        }

        // simple opcodes that are translated directly into one or a few asm instructions
        return when(ins.opcode) {
            Opcode.LINE -> " ;\tsrc line: ${ins.callLabel}"
            Opcode.NOP -> " nop"      // shouldn't be present anymore though
            Opcode.TERMINATE -> " brk"
            Opcode.SEC -> " sec"
            Opcode.CLC -> " clc"
            Opcode.SEI -> " sei"
            Opcode.CLI -> " cli"
            Opcode.JUMP -> " jmp  ${ins.callLabel}"
            Opcode.CALL -> " jsr  ${ins.callLabel}"
            Opcode.RETURN -> " rts"
            Opcode.B2UB -> ""   // is a no-op, just carry on with the byte as-is
            Opcode.UB2B -> ""   // is a no-op, just carry on with the byte as-is
            Opcode.RSAVE -> " php |  pha |  txa |  pha |  tya |  pha"
            Opcode.RRESTORE -> " pla |  tay |  pla |  tax |  pla |  plp"
            Opcode.DISCARD_BYTE -> " inx"
            Opcode.DISCARD_WORD -> " inx"
            Opcode.DISCARD_FLOAT -> " inx |  inx |  inx"
            Opcode.INLINE_ASSEMBLY ->  "@inline@" + (ins.callLabel ?: "")      // All of the inline assembly is stored in the calllabel property.
            Opcode.SYSCALL -> {
                if (ins.arg!!.numericValue() in syscallsForStackVm.map { it.callNr })
                    throw CompilerException("cannot translate vm syscalls to real assembly calls - use *real* subroutine calls instead. Syscall ${ins.arg.numericValue()}")
                TODO("syscall $ins")
            }
            Opcode.BREAKPOINT -> {
                breakpointCounter++
                "_prog8_breakpoint_$breakpointCounter\tnop"
            }

            Opcode.PUSH_BYTE -> {
                " lda  #${ins.arg!!.integerValue().toHex()} |  sta  ${ESTACK_LO.toHex()},x |  dex"
            }
            Opcode.PUSH_WORD -> {
                val value = ins.arg!!.integerValue().toHex()
                " lda  #<$value |  sta  ${ESTACK_LO.toHex()},x |  lda  #>$value |  sta  ${ESTACK_HI.toHex()},x |  dex"
            }
            Opcode.PUSH_FLOAT -> {
                val floatConst = globalFloatConsts[ins.arg!!.numericValue().toDouble()] ?: throw AssemblyError("should have a global float const for number ${ins.arg}")
                " lda  #<$floatConst |  ldy  #>$floatConst |  jsr  prog8_lib.push_float"
            }
            Opcode.PUSH_VAR_BYTE -> {
                when(ins.callLabel) {
                    "X" -> throw CompilerException("makes no sense to push X, it's used as a stack pointer itself")
                    "A" -> " sta  ${ESTACK_LO.toHex()},x |  dex"
                    "Y" -> " tya |  sta  ${ESTACK_LO.toHex()},x |  dex"
                    else -> " lda  ${ins.callLabel} |  sta  ${ESTACK_LO.toHex()},x |  dex"
                }
            }
            Opcode.PUSH_VAR_WORD -> {
                when (ins.callLabel) {
                    "AX" -> throw CompilerException("makes no sense to push X, it's used as a stack pointer itself")
                    "XY" -> throw CompilerException("makes no sense to push X, it's used as a stack pointer itself")
                    "AY" -> " sta  ${ESTACK_LO.toHex()},x |  pha |  tya |  sta  ${ESTACK_HI.toHex()},x |  pla |  dex"
                    else -> " lda  ${ins.callLabel} |  ldy  ${ins.callLabel}+1 |  sta  ${ESTACK_LO.toHex()},x |  pha |  tya |  sta  ${ESTACK_HI.toHex()},x |  pla |  dex"
                }
            }
            Opcode.PUSH_VAR_FLOAT -> " lda  #<${ins.callLabel} |  ldy  #>${ins.callLabel}|  jsr  prog8_lib.push_float"
            Opcode.PUSH_MEM_B, Opcode.PUSH_MEM_UB -> {
                """
                lda  ${ins.arg!!.integerValue().toHex()}
                sta  ${ESTACK_LO.toHex()},x
                dex
                """
            }
            Opcode.PUSH_MEM_W, Opcode.PUSH_MEM_UW -> {
                """
                lda  ${ins.arg!!.integerValue().toHex()}
                sta  ${ESTACK_LO.toHex()},x
                lda  ${(ins.arg.integerValue()+1).toHex()}
                sta  ${ESTACK_HI.toHex()},x
                dex
                """
            }

            Opcode.POP_MEM_B, Opcode.POP_MEM_UB -> {
                """
                inx
                lda  ${ESTACK_LO.toHex()},x
                sta  ${ins.arg!!.integerValue().toHex()}
                """
            }
            Opcode.POP_MEM_W, Opcode.POP_MEM_UW -> {
                """
                inx
                lda  ${ESTACK_LO.toHex()},x
                sta  ${ins.arg!!.integerValue().toHex()}
                lda  ${ESTACK_HI.toHex()},x
                sta  ${(ins.arg.integerValue()+1).toHex()}
                """
            }
            Opcode.POP_VAR_BYTE -> {
                when (ins.callLabel) {
                    "X" -> throw CompilerException("makes no sense to pop X, it's used as a stack pointer itself")
                    "A" -> " inx |  lda  ${ESTACK_LO.toHex()},x"
                    "Y" -> " inx |  ldy  ${ESTACK_LO.toHex()},x"
                    else -> " inx |  lda  ${ESTACK_LO.toHex()},x |  sta  ${ins.callLabel}"
                }
            }
            Opcode.POP_VAR_WORD -> {
                when (ins.callLabel) {
                    "AX" -> throw CompilerException("makes no sense to pop X, it's used as a stack pointer itself")
                    "XY" -> throw CompilerException("makes no sense to pop X, it's used as a stack pointer itself")
                    "AY" -> " inx |  lda  ${ESTACK_LO.toHex()},x |  ldy  ${ESTACK_HI.toHex()},x"
                    else -> " inx |  lda  ${ESTACK_LO.toHex()},x |  ldy  ${ESTACK_HI.toHex()},x |  sta  ${ins.callLabel} |  sty  ${ins.callLabel}+1"
                }
            }
            Opcode.POP_VAR_FLOAT -> {
                " lda  #<${ins.callLabel} |  ldy  #>${ins.callLabel} |  jsr  prog8_lib.pop_var_float"
            }

            Opcode.COPY_VAR_BYTE -> {
                when {
                    ins.callLabel2 in registerStrings -> {
                        val reg2 = ins.callLabel2!!.toLowerCase()
                        if (ins.callLabel in registerStrings) {
                            val reg1 = ins.callLabel!!.toLowerCase()
                            // register -> register
                            return when {
                                reg1 == "a" -> " ta$reg2"
                                reg2 == "a" -> " t${reg1}a"
                                else -> " t${reg1}a |  ta$reg2"   // 6502 doesn't have tyx/txy
                            }
                        }
                        // var -> reg
                        return " ld${ins.callLabel2.toLowerCase()}  ${ins.callLabel}"
                    }
                    ins.callLabel in registerStrings ->
                        // reg -> var
                        return " st${ins.callLabel!!.toLowerCase()}  ${ins.callLabel2}"
                    else ->
                        // var -> var
                        return " lda  ${ins.callLabel}\n\tsta  ${ins.callLabel2}"
                }
            }
            Opcode.COPY_VAR_WORD -> {
                when {
                    ins.callLabel2 in registerStrings -> {
                        if (ins.callLabel in registerStrings) {
                            // copying registerpair -> registerpair
                            when {
                                ins.callLabel == "AX" -> return when (ins.callLabel2) {
                                    "AY" -> " txy"
                                    "XY" -> " stx  ${C64Zeropage.SCRATCH_B1.toHex()} |  tax  |  ldy ${C64Zeropage.SCRATCH_B1.toHex()}"
                                    else -> ""
                                }
                                ins.callLabel == "AY" -> return when (ins.callLabel2) {
                                    "AX" -> " sty  ${C64Zeropage.SCRATCH_B1.toHex()} |  ldx ${C64Zeropage.SCRATCH_B1.toHex()}"
                                    "XY" -> " tax"
                                    else -> ""
                                }
                                else /* XY */ -> return when (ins.callLabel2) {
                                    "AX" -> " txa |  sty  ${C64Zeropage.SCRATCH_B1.toHex()} |  ldx  ${C64Zeropage.SCRATCH_B1.toHex()}"
                                    "AY" -> " txa"
                                    else -> ""
                                }
                            }
                        }
                        // wvar  -> regpair
                        val regpair = ins.callLabel2!!.toLowerCase()
                        return " ld${regpair[0]}  ${ins.callLabel} |  ld${regpair[1]}  ${ins.callLabel}+1"
                    }
                    ins.callLabel in registerStrings -> {
                        // regpair->wvar
                        val regpair = ins.callLabel!!.toLowerCase()
                        return " st${regpair[0]}  ${ins.callLabel2} |  st${regpair[1]}  ${ins.callLabel2}+1"
                    }
                    else -> {
                        // wvar->wvar
                        return " lda  ${ins.callLabel} |  sta  ${ins.callLabel2} | " +
                               " lda  ${ins.callLabel}+1 |  sta  ${ins.callLabel2}+1"
                    }
                }
            }
            Opcode.COPY_VAR_FLOAT -> {
                """
                lda  #<${ins.callLabel}
                ldy  #>${ins.callLabel}
                sta  ${C64Zeropage.SCRATCH_W1}
                sty  ${C64Zeropage.SCRATCH_W1+1}
                lda  #<${ins.callLabel2}
                ldy  #>${ins.callLabel2}
                sta  ${C64Zeropage.SCRATCH_W2}
                sty  ${C64Zeropage.SCRATCH_W2+1}
                jsr  prog8_lib.copy_float
                """
            }

            Opcode.INC_VAR_UB, Opcode.INC_VAR_B -> {
                when (ins.callLabel) {
                    "A" -> " clc |  adc  #1"
                    "X" -> " inx"
                    "Y" -> " iny"
                    else -> " inc  ${ins.callLabel}"
                }
            }
            Opcode.INC_VAR_UW -> {
                when (ins.callLabel) {
                    "AX" -> " clc |  adc  #1 |  bne  + |  inx |+"
                    "AY" -> " clc |  adc  #1 |  bne  + |  iny |+"
                    "XY" -> " inx |  bne  + |  iny  |+"
                    else -> " inc  ${ins.callLabel} |  bne  + |  inc  ${ins.callLabel}+1 |+"
                }
            }
            Opcode.INC_VAR_F -> {
                """
                lda  #<${ins.callLabel}
                ldy  #>${ins.callLabel}
                jsr  prog8_lib.inc_var_f
                """
            }
            Opcode.DEC_VAR_UB, Opcode.DEC_VAR_B -> {
                when (ins.callLabel) {
                    "A" -> " sec |  sbc  #1"
                    "X" -> " dex"
                    "Y" -> " dey"
                    else -> " dec  ${ins.callLabel}"
                }
            }
            Opcode.DEC_VAR_UW -> {
                when (ins.callLabel) {
                    "AX" -> " cmp  #0 |  bne  + |  dex |+ |  sec |  sbc  #1"
                    "AY" -> " cmp  #0 |  bne  + |  dey |+ |  sec |  sbc  #1"
                    "XY" -> " txa |  bne + |  dey |+ | dex"
                    else -> " lda  ${ins.callLabel} |  bne  + |  dec  ${ins.callLabel}+1 |+ |  dec  ${ins.callLabel}"
                }
            }
            Opcode.DEC_VAR_F -> {
                """
                lda  #<${ins.callLabel}
                ldy  #>${ins.callLabel}
                jsr  prog8_lib.dec_var_f
                """
            }
            Opcode.NEG_B -> {
                """
                lda  ${(ESTACK_LO+1).toHex()},x
                eor  #255
                sec
                adc  #0
                sta  ${(ESTACK_LO+1).toHex()},x
                """
            }
            Opcode.INV_BYTE -> {
                """
                lda  ${(ESTACK_LO + 1).toHex()},x
                eor  #255
                sta  ${(ESTACK_LO + 1).toHex()},x
                """
            }
            Opcode.INV_WORD -> {
                """
                lda  ${(ESTACK_LO + 1).toHex()},x
                eor  #255
                sta  ${(ESTACK_LO+1).toHex()},x
                lda  ${(ESTACK_HI + 1).toHex()},x
                eor  #255
                sta  ${(ESTACK_HI+1).toHex()},x
                """
            }
            Opcode.NOT_BYTE -> {
                """
                lda  ${(ESTACK_LO+1).toHex()},x
                beq  +
                lda  #0
                beq ++
+               lda  #1
+               sta  ${(ESTACK_LO+1).toHex()},x
                """
            }
            Opcode.NOT_WORD -> {
                """
                lda  ${(ESTACK_LO + 1).toHex()},x
                ora  ${(ESTACK_HI + 1).toHex()},x
                beq  +
                lda  #0
                beq  ++
+               lda  #1
+               sta  ${(ESTACK_LO + 1).toHex()},x |  sta  ${(ESTACK_HI + 1).toHex()},x
                """
            }

            Opcode.BCS -> " bcs  ${ins.callLabel}"
            Opcode.BCC -> " bcc  ${ins.callLabel}"
            Opcode.BZ -> " beq  ${ins.callLabel}"
            Opcode.BNZ -> " bne  ${ins.callLabel}"
            Opcode.BNEG -> " bmi  ${ins.callLabel}"
            Opcode.BPOS -> " bpl  ${ins.callLabel}"
            Opcode.UB2FLOAT -> " jsr  prog8_lib.ub2float"
            Opcode.B2FLOAT -> " jsr  prog8_lib.b2float"
            Opcode.UW2FLOAT -> " jsr  prog8_lib.uw2float"
            Opcode.W2FLOAT -> " jsr  prog8_lib.w2float"

            Opcode.DIV_UB -> "  jsr  prog8_lib.div_ub"
            Opcode.DIV_B -> "  jsr  prog8_lib.div_b"
            Opcode.DIV_F -> "  jsr  prog8_lib.div_f"
            Opcode.DIV_W -> "  jsr  prog8_lib.div_w"
            Opcode.DIV_UW -> "  jsr  prog8_lib.div_uw"
            Opcode.ADD_UB, Opcode.ADD_B -> {
                """
                lda  ${(ESTACK_LO + 2).toHex()},x
                clc
                adc  ${(ESTACK_LO + 1).toHex()},x
                inx
                sta  ${(ESTACK_LO + 1).toHex()},x
                """
            }
            Opcode.SUB_UB, Opcode.SUB_B -> {
                """
                lda  ${(ESTACK_LO + 2).toHex()},x
                sec
                sbc  ${(ESTACK_LO + 1).toHex()},x
                inx
                sta  ${(ESTACK_LO + 1).toHex()},x
                """
            }
            Opcode.ADD_F -> "  jsr  prog8_lib.add_f"
            Opcode.ADD_W -> "  jsr  prog8_lib.add_w"    // todo or inline rather
            Opcode.ADD_UW -> "  jsr  prog8_lib.add_uw"  // todo or inline rather
            Opcode.SUB_F -> "  jsr  prog8_lib.sub_f"
            Opcode.SUB_W -> "  jsr  prog8_lib.sub_w"    // todo or inline rather
            Opcode.SUB_UW -> "  jsr  prog8_lib.sub_uw"    // todo or inline rather
            Opcode.MUL_F -> "  jsr  prog8_lib.mul_f"
            Opcode.MUL_B -> "  jsr  prog8_lib.mul_b"
            Opcode.MUL_UB -> "  jsr  prog8_lib.mul_ub"
            Opcode.MUL_W -> "  jsr  prog8_lib.mul_w"
            Opcode.MUL_UW -> "  jsr  prog8_lib.mul_uw"
            Opcode.LESS_UB -> "  jsr  prog8_lib.less_ub"
            Opcode.LESS_B -> "  jsr  prog8_lib.less_b"
            Opcode.LESS_UW -> "  jsr  prog8_lib.less_uw"
            Opcode.LESS_W -> "  jsr  prog8_lib.less_w"
            Opcode.LESS_F -> "  jsr  prog8_lib.less_f"

            Opcode.AND_BYTE -> {
                """
                lda  ${(ESTACK_LO + 2).toHex()},x
                and  ${(ESTACK_LO + 1).toHex()},x
                inx
                sta  ${(ESTACK_LO + 1).toHex()},x
                """
            }
            Opcode.OR_BYTE -> {
                """
                lda  ${(ESTACK_LO + 2).toHex()},x
                ora  ${(ESTACK_LO + 1).toHex()},x
                inx
                sta  ${(ESTACK_LO + 1).toHex()},x
                """
            }

            else -> null
        }
    }

    private fun findPatterns(segment: List<Instruction>): List<AsmFragment> {
        val opcodes = segment.map { it.opcode }
        val result = mutableListOf<AsmFragment>()

        // check for regular 'assignments'  (a push immediately followed by a pop)
        if(opcodes[0] in pushOpcodes && opcodes[1] in popOpcodes) {
            when(opcodes[0]) {
                Opcode.PUSH_BYTE -> when(opcodes[1]) {
                    Opcode.POP_VAR_BYTE -> {
                        result.add(AsmFragment(
                                " lda  #${segment[0].arg!!.integerValue().toHex()} |  sta  ${segment[1].callLabel}",
                                10, 2))
                    }
                    else -> TODO("pop byte ${segment[1]}")
                }
                Opcode.PUSH_WORD -> when(opcodes[1]) {
                    Opcode.POP_VAR_WORD -> {
                        result.add(AsmFragment(
                                """
                                lda  #<${segment[0].arg!!.integerValue().toHex()}
                                sta  ${segment[1].callLabel}
                                lda  #>${segment[0].arg!!.integerValue().toHex()}
                                sta  ${segment[1].callLabel}+1
                                """,
                                10, 2))
                    }
                    else -> TODO("pop word ${segment[1]}")
                }
                Opcode.PUSH_FLOAT -> {
                    val floatConst = globalFloatConsts[segment[0].arg!!.numericValue().toDouble()] ?: throw AssemblyError("should have a global float const for number ${segment[0].arg}")
                    result.add(AsmFragment(
                        """
                        lda  #<$floatConst
                        ldy  #>$floatConst
                        sta  ${C64Zeropage.SCRATCH_W1}
                        sty  ${C64Zeropage.SCRATCH_W1+1}
                        lda  #<${segment[1].callLabel}
                        ldy  #>${segment[1].callLabel}
                        sta  ${C64Zeropage.SCRATCH_W2}
                        sty  ${C64Zeropage.SCRATCH_W2+1}
                        jsr  prog8_lib.copy_float
                        """, 10,2))
                }
                Opcode.PUSH_MEM_B -> TODO("assignment  ${segment[0]}  -->  ${segment[1]}")
                Opcode.PUSH_MEM_UB -> TODO("assignment  ${segment[0]}  -->  ${segment[1]}")
                Opcode.PUSH_MEM_W -> TODO("assignment  ${segment[0]}  -->  ${segment[1]}")
                Opcode.PUSH_MEM_UW -> TODO("assignment  ${segment[0]}  -->  ${segment[1]}")
                Opcode.PUSH_MEM_FLOAT -> TODO("assignment  ${segment[0]}  -->  ${segment[1]}")
                Opcode.PUSH_VAR_BYTE -> {
                    if(opcodes[1] == Opcode.POP_VAR_BYTE)
                        throw AssemblyError("push+pop var byte should have been changed into COPY_VAR_BYTE opcode")
                    else TODO("assignment  ${segment[0]}  -->  ${segment[1]}")
                }
                Opcode.PUSH_VAR_WORD -> {
                    if(opcodes[1] == Opcode.POP_VAR_WORD)
                        throw AssemblyError("push+pop var word should have been changed into COPY_VAR_WORD opcode")
                    else TODO("assignment  ${segment[0]}  -->  ${segment[1]}")
                }
                Opcode.PUSH_VAR_FLOAT -> {
                    if(opcodes[1] == Opcode.POP_VAR_FLOAT)
                        throw AssemblyError("push+pop var float should have been changed into COPY_VAR_FLOAT opcode")
                    else TODO("assignment  ${segment[0]}  -->  ${segment[1]}")
                }
                else -> throw AssemblyError("strange push opcode ${segment[0]}")
            }
        }

        // check for operations that modify a single value, by putting it on the stack (and popping it afterwards)

        else if((opcodes[0]==Opcode.PUSH_VAR_BYTE && opcodes[2]==Opcode.POP_VAR_BYTE) ||
                (opcodes[0]==Opcode.PUSH_VAR_WORD && opcodes[2]==Opcode.POP_VAR_WORD)) {
            if (segment[0].callLabel == segment[2].callLabel) {
                val fragment = sameVarOperation(segment[0].callLabel!!, segment[1])
                if (fragment != null) {
                    fragment.segmentSize = 3
                    result.add(fragment)
                }
            }
        }
        else if((opcodes[0]==Opcode.PUSH_MEM_UB && opcodes[2]==Opcode.POP_MEM_UB) ||
                (opcodes[0]==Opcode.PUSH_MEM_UW && opcodes[2]==Opcode.POP_MEM_UW)) {
            if(segment[0].arg==segment[2].arg) {
                val fragment = sameMemOperation(segment[0].arg!!.integerValue(), segment[1])
                if(fragment!=null) {
                    fragment.segmentSize = 3
                    result.add(fragment)
                }
            }
        }
        else if((opcodes[0]==Opcode.PUSH_BYTE && opcodes[1]==Opcode.READ_INDEXED_VAR_BYTE &&
                        opcodes[3]==Opcode.PUSH_BYTE && opcodes[4]==Opcode.WRITE_INDEXED_VAR_BYTE) ||
                (opcodes[0]==Opcode.PUSH_BYTE && opcodes[1]==Opcode.READ_INDEXED_VAR_WORD &&
                        opcodes[3]==Opcode.PUSH_BYTE && opcodes[4]==Opcode.WRITE_INDEXED_VAR_WORD)) {
            if(segment[0].arg==segment[3].arg && segment[1].callLabel==segment[4].callLabel) {
                val fragment = sameConstantIndexedVarOperation(segment[1].callLabel!!, segment[0].arg!!.integerValue(), segment[2])
                if(fragment!=null){
                    fragment.segmentSize = 5
                    result.add(fragment)
                }
            }
        }
        else if((opcodes[0]==Opcode.PUSH_VAR_BYTE && opcodes[1]==Opcode.READ_INDEXED_VAR_BYTE &&
                        opcodes[3]==Opcode.PUSH_VAR_BYTE && opcodes[4]==Opcode.WRITE_INDEXED_VAR_BYTE) ||
                (opcodes[0]==Opcode.PUSH_VAR_BYTE && opcodes[1]==Opcode.READ_INDEXED_VAR_WORD &&
                        opcodes[3]==Opcode.PUSH_VAR_BYTE && opcodes[4]==Opcode.WRITE_INDEXED_VAR_WORD)) {
            if(segment[0].callLabel==segment[3].callLabel && segment[1].callLabel==segment[4].callLabel) {
                val fragment = sameIndexedVarOperation(segment[1].callLabel!!, segment[0].callLabel!!, segment[2])
                if(fragment!=null){
                    fragment.segmentSize = 5
                    result.add(fragment)
                }
            }
        }

        for(pattern in patterns.filter { it.sequence.size <= segment.size}) {
            if(pattern.sequence == opcodes.subList(0, pattern.sequence.size)) {
                val asm = pattern.asm(segment)
                if(asm!=null)
                    result.add(AsmFragment(asm, pattern.prio, pattern.sequence.size))
            }
        }

        return result
    }

    private fun sameConstantIndexedVarOperation(variable: String, index: Int, ins: Instruction): AsmFragment? {
        return when(ins.opcode) {
            Opcode.SHL_BYTE -> AsmFragment(" asl  $variable+$index", 8)
            Opcode.SHR_BYTE -> AsmFragment(" lsr  $variable+$index", 8)
            Opcode.SHL_WORD -> AsmFragment(" asl  $variable+$index |  rol  $variable+$index+1", 8)
            Opcode.SHR_WORD -> AsmFragment(" lsr  $variable+$index+1,x |  ror  $variable+$index", 8)
            Opcode.ROL_BYTE -> AsmFragment(" rol  $variable+$index", 8)
            Opcode.ROR_BYTE -> AsmFragment(" ror  $variable+$index", 8)
            Opcode.ROL_WORD -> AsmFragment(" rol  $variable+$index |  rol  $variable+$index+1", 8)
            Opcode.ROR_WORD -> AsmFragment(" ror  $variable+$index+1 |  ror  $variable+$index", 8)
            Opcode.ROL2_BYTE -> AsmFragment(" lda  $variable+$index |  cmp  #\$80 |  rol  $variable+$index", 8)
            Opcode.ROR2_BYTE -> AsmFragment(" lda  $variable+$index |  lsr  a |  bcc  + |  ora  #\$80 |+ |  sta  $variable+$index", 10)
            Opcode.ROL2_WORD -> AsmFragment(" asl  $variable+$index |  rol  $variable+$index+1 |  bcc  + |  inc  $variable+$index |+",20)
            Opcode.ROR2_WORD -> AsmFragment(" lsr  $variable+$index+1 |  ror  $variable+$index |  bcc  + |  lda  $variable+$index+1 |  ora  #\$80 |  sta  $variable+$index+1 |+", 30)
            else -> null
        }
    }

    private fun sameIndexedVarOperation(variable: String, indexVar: String, ins: Instruction): AsmFragment? {
        val saveX = " stx  ${C64Zeropage.SCRATCH_B1} |"         // todo optimize to TXA when possible
        val restoreX = " | ldx  ${C64Zeropage.SCRATCH_B1}"
        val loadXWord: String
        val loadX: String

        when(indexVar) {
            "X" -> {
                loadX = ""
                loadXWord = " txa |  asl a |  tax |"
            }
            "Y" -> {
                loadX = " tya |  tax |"
                loadXWord = " tya |  asl a |  tax |"
            }
            "A" -> {
                loadX = " tax |"
                loadXWord = " asl a |  tax |"
            }
            "AX", "AY", "XY" -> throw AssemblyError("cannot index with word/registerpair")
            else -> {
                // the indexvar is a real variable, not a register
                loadX = " ldx  $indexVar |"
                loadXWord = " lda  $indexVar |  asl  a |  tax |"
            }
        }

        return when (ins.opcode) {
            Opcode.SHL_BYTE -> AsmFragment("$saveX $loadX  asl  $variable,x  $restoreX", 10)
            Opcode.SHR_BYTE -> AsmFragment("$saveX $loadX  lsr  $variable,x  $restoreX", 10)
            Opcode.SHL_WORD -> AsmFragment("$saveX $loadXWord  asl  $variable,x |  rol  $variable+1,x  $restoreX", 10)
            Opcode.SHR_WORD -> AsmFragment("$saveX $loadXWord  lsr  $variable+1,x |  ror  $variable,x  $restoreX", 10)
            Opcode.ROL_BYTE -> AsmFragment("$saveX $loadX  rol  $variable,x  $restoreX", 10)
            Opcode.ROR_BYTE -> AsmFragment("$saveX $loadX  ror  $variable,x  $restoreX", 10)
            Opcode.ROL_WORD -> AsmFragment("$saveX $loadXWord  rol  $variable,x |  rol  $variable+1,x  $restoreX", 10)
            Opcode.ROR_WORD -> AsmFragment("$saveX $loadXWord  ror  $variable+1,x |  ror  $variable,x  $restoreX", 10)
            Opcode.ROL2_BYTE -> AsmFragment("$saveX $loadX  lda  $variable,x |  cmp  #\$80 |  rol  $variable,x  $restoreX", 10)
            Opcode.ROR2_BYTE -> AsmFragment("$saveX $loadX  lda  $variable,x |  lsr  a |  bcc  + |  ora  #\$80 |+ |  sta  $variable,x  $restoreX", 10)
            Opcode.ROL2_WORD -> AsmFragment("$saveX $loadXWord  asl  $variable,x |  rol  $variable+1,x |  bcc  + |  inc  $variable,x  |+  $restoreX", 30)
            Opcode.ROR2_WORD -> AsmFragment("$saveX $loadXWord  lsr  $variable+1,x |  ror  $variable,x |  bcc  + |  lda  $variable+1,x |  ora  #\$80 |  sta  $variable+1,x |+  $restoreX", 30)
            else -> null
        }
    }

    private fun sameMemOperation(address: Int, ins: Instruction): AsmFragment? {
        val addr = address.toHex()
        val addrHi = (address+1).toHex()
        return when(ins.opcode) {
            Opcode.SHL_BYTE -> AsmFragment(" asl  $addr", 10)
            Opcode.SHR_BYTE -> AsmFragment(" lsr  $addr", 10)
            Opcode.SHL_WORD -> AsmFragment(" asl  $addr |  rol  $addrHi", 10)
            Opcode.SHR_WORD -> AsmFragment(" lsr  $addrHi |  ror  $addr", 10)
            Opcode.ROL_BYTE -> AsmFragment(" rol  $addr", 10)
            Opcode.ROR_BYTE -> AsmFragment(" ror  $addr", 10)
            Opcode.ROL_WORD -> AsmFragment(" rol  $addr |  rol  $addrHi", 10)
            Opcode.ROR_WORD -> AsmFragment(" ror  $addrHi |  ror  $addr", 10)
            Opcode.ROL2_BYTE -> AsmFragment(" lda  $addr |  cmp  #\$80 |  rol  $addr", 10)
            Opcode.ROR2_BYTE -> AsmFragment(" lda  $addr |  lsr  a |  bcc  + |  ora  #\$80 |+ |  sta  $addr", 10)
            Opcode.ROL2_WORD -> AsmFragment(" lda  $addr |  cmp #\$80 |  rol  $addr |  rol  $addrHi", 10)
            Opcode.ROR2_WORD -> AsmFragment(" lsr  $addrHi |  ror  $addr |  bcc  + |  lda  $addrHi |  ora  #$80 |  sta  $addrHi |+", 20)
            else -> null
        }
    }

    private fun sameVarOperation(variable: String, ins: Instruction): AsmFragment? {
        return when(ins.opcode) {
            Opcode.SHL_BYTE -> {
                when (variable) {
                    "A" -> AsmFragment(" asl  a", 10)
                    "X" -> AsmFragment(" txa |  asl  a |  tax", 10)
                    "Y" -> AsmFragment(" tya |  asl  a |  tay", 10)
                    else -> AsmFragment(" asl  $variable", 10)
                }
            }
            Opcode.SHR_BYTE -> {
                when (variable) {
                    "A" -> AsmFragment(" lsr  a", 10)
                    "X" -> AsmFragment(" txa |  lsr  a |  tax", 10)
                    "Y" -> AsmFragment(" tya |  lsr  a |  tay", 10)
                    else -> AsmFragment(" lsr  $variable", 10)
                }
            }
            Opcode.SHL_WORD -> {
                when(variable) {
                    "AX" -> AsmFragment(" asl  a |  tay |  txa |  rol  a |  tax  |  tya ", 10)
                    "AY" -> AsmFragment(" sty  ${C64Zeropage.SCRATCH_B1.toHex()} |  asl  a |  rol  ${C64Zeropage.SCRATCH_B1.toHex()} |  ldy  ${C64Zeropage.SCRATCH_B1.toHex()} ", 10)
                    "XY" -> AsmFragment(" sty  ${C64Zeropage.SCRATCH_B1.toHex()} |  txa |  asl  a |  rol  ${C64Zeropage.SCRATCH_B1.toHex()} |  ldy  ${C64Zeropage.SCRATCH_B1.toHex()} |  tax", 10)
                    else -> AsmFragment(" asl  $variable |  rol  $variable+1", 10)
                }
            }
            Opcode.SHR_WORD -> {
                when(variable) {
                    "AX" -> AsmFragment(" tay |  txa |  lsr  a |  tax  |  tya |  ror  a", 10)
                    "AY" -> AsmFragment(" sty  ${C64Zeropage.SCRATCH_B1.toHex()} |  lsr  ${C64Zeropage.SCRATCH_B1.toHex()} |  ror  a |  ldy  ${C64Zeropage.SCRATCH_B1.toHex()} ", 10)
                    "XY" -> AsmFragment(" sty  ${C64Zeropage.SCRATCH_B1.toHex()} |  lsr  ${C64Zeropage.SCRATCH_B1.toHex()} |  txa |  ror a  | tax  | ldy  ${C64Zeropage.SCRATCH_B1.toHex()}", 10)
                    else -> AsmFragment(" lsr  $variable+1 |  ror  $variable", 10)
                }
            }
            Opcode.ROL_BYTE -> {
                when (variable) {
                    "A" -> AsmFragment(" rol  a", 10)
                    "X" -> AsmFragment(" txa |  rol  a |  tax", 10)
                    "Y" -> AsmFragment(" tya |  rol  a |  tay", 10)
                    else -> AsmFragment(" rol  $variable", 10)
                }
            }
            Opcode.ROR_BYTE -> {
                when (variable) {
                    "A" -> AsmFragment(" ror  a", 10)
                    "X" -> AsmFragment(" txa |  ror  a |  tax", 10)
                    "Y" -> AsmFragment(" tya |  ror  a |  tay", 10)
                    else -> AsmFragment(" ror  $variable", 10)
                }
            }
            Opcode.ROL_WORD -> {
                when(variable) {
                    "AX" -> AsmFragment(" rol  a |  tay |  txa |  rol  a |  tax  |  tya ", 10)
                    "AY" -> AsmFragment(" sty  ${C64Zeropage.SCRATCH_B1} |  rol  a |  rol  ${C64Zeropage.SCRATCH_B1} |  ldy  ${C64Zeropage.SCRATCH_B1} ", 10)
                    "XY" -> AsmFragment(" sty  ${C64Zeropage.SCRATCH_B1} |  txa |  rol  a |  rol  ${C64Zeropage.SCRATCH_B1} |  ldy  ${C64Zeropage.SCRATCH_B1} |  tax", 10)
                    else -> AsmFragment(" rol  $variable |  rol  $variable+1", 10)
                }
            }
            Opcode.ROR_WORD -> {
                when(variable) {
                    "AX" -> AsmFragment(" tay |  txa |  ror  a |  tax  |  tya |  ror  a", 10)
                    "AY" -> AsmFragment(" sty  ${C64Zeropage.SCRATCH_B1} |  ror  ${C64Zeropage.SCRATCH_B1} |  ror  a |  ldy  ${C64Zeropage.SCRATCH_B1} ", 10)
                    "XY" -> AsmFragment(" sty  ${C64Zeropage.SCRATCH_B1} |  ror  ${C64Zeropage.SCRATCH_B1} |  txa |  ror a  | tax  | ldy  ${C64Zeropage.SCRATCH_B1}", 10)
                    else -> AsmFragment(" ror  $variable+1 |  ror  $variable", 10)
                }
            }
            Opcode.ROL2_BYTE -> {       // 8-bit rol
                when (variable) {
                    "A" -> AsmFragment(" cmp  #\$80 |  rol  a", 10)
                    "X" -> AsmFragment(" txa |  cmp  #\$80 |  rol  a |  tax", 10)
                    "Y" -> AsmFragment(" tya |  cmp  #\$80 |  rol  a |  tay", 10)
                    else -> AsmFragment(" lda  $variable |  cmp  #\$80  | rol  $variable", 10)
                }
            }
            Opcode.ROR2_BYTE -> {       // 8-bit ror
                when (variable) {
                    "A" -> AsmFragment(" lsr  a | bcc  + |  ora  #\$80  |+", 10)
                    "X" -> AsmFragment(" txa |  lsr  a |  bcc  + |  ora  #\$80  |+ |  tax", 10)
                    "Y" -> AsmFragment(" tya |  lsr  a |  bcc  + |  ora  #\$80  |+ |  tay", 10)
                    else -> AsmFragment(" lda  $variable |  lsr  a |  bcc  + |  ora  #\$80 |+ |  sta  $variable", 10)
                }
            }
            Opcode.ROL2_WORD -> {
                when(variable) {
                    "AX" -> AsmFragment(" cmp  #\$80 |  rol  a |  tay |  txa |  rol  a |  tax |  tya", 10)
                    "AY" -> AsmFragment(" sty  ${C64Zeropage.SCRATCH_B1} |  cmp  #\$80 |  rol  a |  rol  ${C64Zeropage.SCRATCH_B1} |  ldy  ${C64Zeropage.SCRATCH_B1} ", 10)
                    "XY" -> AsmFragment(" sty  ${C64Zeropage.SCRATCH_B1} |  txa |  cmp  #\$80 |  rol  a |  rol  ${C64Zeropage.SCRATCH_B1} |  ldy  ${C64Zeropage.SCRATCH_B1} |  tax", 10)
                    else -> AsmFragment(" lda  $variable |  cmp #\$80 |  rol  $variable |  rol  $variable+1", 10)
                }
            }
            Opcode.ROR2_WORD -> {
                // todo: ror2_word is very slow; it requires a library routine
                when(variable) {
                    "AX" -> AsmFragment(" sta  ${C64Zeropage.SCRATCH_W1} |  stx  ${C64Zeropage.SCRATCH_W1+1}  |  jsr  prog8_lib.ror2_word |  lda  ${C64Zeropage.SCRATCH_W1} |  ldx  ${C64Zeropage.SCRATCH_W1+1}", 20)
                    "AY" -> AsmFragment(" sta  ${C64Zeropage.SCRATCH_W1} |  sty  ${C64Zeropage.SCRATCH_W1+1}  |  jsr  prog8_lib.ror2_word |  lda  ${C64Zeropage.SCRATCH_W1} |  ldy  ${C64Zeropage.SCRATCH_W1+1}", 20)
                    "XY" -> AsmFragment(" stx  ${C64Zeropage.SCRATCH_W1} |  sty  ${C64Zeropage.SCRATCH_W1+1}  |  jsr  prog8_lib.ror2_word |  ldx  ${C64Zeropage.SCRATCH_W1} |  ldy  ${C64Zeropage.SCRATCH_W1+1}", 20)
                    else -> AsmFragment(" lda  $variable |  sta  ${C64Zeropage.SCRATCH_W1} |  lda  $variable+1 |  sta  ${C64Zeropage.SCRATCH_W1+1} |  jsr prog8_lib.ror2_word |  lda  ${C64Zeropage.SCRATCH_W1} |  sta  $variable |  lda  ${C64Zeropage.SCRATCH_W1+1} |  sta  $variable+1", 30)
                }
            }
            else -> null
        }
    }

    class AsmFragment(val asm: String, val prio: Int, var segmentSize: Int=0)

    class AsmPattern(val sequence: List<Opcode>, val prio: Int, val asm: (List<Instruction>)->String?)

    private val patterns = listOf(
            AsmPattern(listOf(Opcode.PUSH_BYTE, Opcode.POP_VAR_BYTE), 10) { segment ->
                when (segment[1].callLabel) {
                    "A", "X", "Y" -> " ld${segment[1].callLabel!!.toLowerCase()}  #${segment[0].arg!!.integerValue().toHex()}"
                    else -> null
                }
            },
            AsmPattern(listOf(Opcode.PUSH_WORD, Opcode.POP_VAR_WORD), 10) { segment ->
                val number = segment[0].arg!!.integerValue().toHex()
                when (segment[1].callLabel) {
                    "AX" -> " lda  #<$number |  ldx  #>$number"
                    "AY" -> " lda  #<$number |  ldy  #>$number"
                    "XY" -> " ldx  #<$number |  ldy  #>$number"
                    else -> null
                }
            },
            AsmPattern(listOf(Opcode.PUSH_BYTE, Opcode.READ_INDEXED_VAR_BYTE, Opcode.POP_VAR_BYTE), 10) { segment ->
                val index = segment[0].arg!!.integerValue()
                when (segment[2].callLabel) {
                    "A", "X", "Y" -> " ld${segment[2].callLabel!!.toLowerCase()}  ${segment[1].callLabel}+$index"
                    else -> null
                }
            }
    )
}
