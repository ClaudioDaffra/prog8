package prog8.compiler.target.c64

import prog8.ast.DataType
import prog8.compiler.*
import prog8.compiler.intermediate.*
import java.io.File
import java.io.PrintWriter
import java.util.*
import kotlin.math.abs


class AssemblyError(msg: String) : RuntimeException(msg)


class AsmGen(val options: CompilationOptions, val program: IntermediateProgram, val heap: HeapValues) {
    private val globalFloatConsts = mutableMapOf<Double, String>()
    private lateinit var output: PrintWriter

    init {
        // Because 64tass understands scoped names via .proc / .block,
        // we'll strip the block prefix from all scoped names in the program.
        // Also, convert invalid label names (such as "<<<anonymous-1>>>") to something that's allowed.
        val newblocks = mutableListOf<IntermediateProgram.ProgramBlock>()
        for(block in program.blocks) {
            val newvars = block.variables.map { symname(it.key, block) to it.value }.toMap().toMutableMap()
            val newlabels = block.labels.map { symname(it.key, block) to it.value}.toMap().toMutableMap()
            val newinstructions = block.instructions.asSequence().map {
                when {
                    it is LabelInstr -> LabelInstr(symname(it.name, block))
                    it.opcode == Opcode.INLINE_ASSEMBLY -> it
                    else -> Instruction(it.opcode, it.arg,
                            if (it.callLabel != null) symname(it.callLabel, block) else null,
                            if (it.callLabel2 != null) symname(it.callLabel2, block) else null)
                }
            }.toMutableList()
            val newConstants = block.integerConstants.map { symname(it.key, block) to it.value }.toMap().toMutableMap()
            newblocks.add(IntermediateProgram.ProgramBlock(
                    block.scopedname,
                    block.shortname,
                    block.address,
                    newinstructions,
                    newvars,
                    newConstants,
                    newlabels))
        }
        program.blocks.clear()
        program.blocks.addAll(newblocks)

        // make a list of all const floats that are used
        for(block in program.blocks) {
            for(ins in block.instructions.filter{it.arg?.type==DataType.FLOAT}) {
                val float = ins.arg!!.numericValue().toDouble()
                if(float !in globalFloatConsts)
                    globalFloatConsts[float] = "prog8_const_float_${globalFloatConsts.size}"
            }
        }
    }

    private fun out(str: String?) = output.println(str)

    fun compileToAssembly(): AssemblyProgram {
        println("\nGenerating assembly code from intermediate code... ")

        // todo generate 6502 assembly
        output = File("${program.name}.asm").printWriter()
        output.use {
            header()
            for(block in program.blocks)
                block2asm(block)
        }

        return AssemblyProgram(program.name)
    }

    private fun symname(scoped: String, block: IntermediateProgram.ProgramBlock): String {
        if(' ' in scoped)
            return scoped

        val blockLocal: Boolean
        var name = if (scoped.startsWith("${block.shortname}.")) {
            blockLocal = true
            scoped.substring(block.shortname.length+1)
        } else {
            blockLocal = false
            scoped
        }
        name = name.replace("<<<", "prog8_").replace(">>>", "")
        if(name=="-")
            return "-"
        if(blockLocal)
            name = name.replace(".", "_")
        else {
            val parts = name.split(".", limit=2)
            if(parts.size>1)
                name = "${parts[0]}.${parts[1].replace(".", "_")}"
        }
        return name.replace("-", "")
    }


    private fun copyFloat(source: String, target: String) {
        // todo: optimize this to bulk copy all floats in the same loop
        out("\tldy #4")
        out("-\tlda  $source,y")
        out("\tsta  $target,y")
        out("\tdey")
        out("\tbpl  -")
    }

    private fun makeFloatFill(flt: Mflpt5): String {
        val b0 = "$"+flt.b0.toString(16).padStart(2, '0')
        val b1 = "$"+flt.b1.toString(16).padStart(2, '0')
        val b2 = "$"+flt.b2.toString(16).padStart(2, '0')
        val b3 = "$"+flt.b3.toString(16).padStart(2, '0')
        val b4 = "$"+flt.b4.toString(16).padStart(2, '0')
        return "$b0, $b1, $b2, $b3, $b4"
    }

    private fun header() {
        val ourName = this.javaClass.name
        out("; 6502 assembly code for '${program.name}'")
        out("; generated by $ourName on ${Date()}")
        out("; assembler syntax is for the 64tasm cross-assembler")
        out("; output options: output=${options.output} launcher=${options.launcher} zp=${options.zeropage}")
        out("\n.cpu  '6502'\n.enc  'none'\n")

        if(program.loadAddress==0)   // fix load address
            program.loadAddress = if(options.launcher==LauncherType.BASIC) BASIC_LOAD_ADDRESS else RAW_LOAD_ADDRESS

        when {
            options.launcher == LauncherType.BASIC -> {
                if (program.loadAddress != 0x0801)
                    throw AssemblyError("BASIC output must have load address $0801")
                out("; ---- basic program with sys call ----")
                out("* = ${program.loadAddress.toHex()}")
                val year = Calendar.getInstance().get(Calendar.YEAR)
                out("\t.word  (+), $year")
                out("\t.null  $9e, format(' %d ', _prog8_entrypoint), $3a, $8f, ' prog8 by idj'")
                out("+\t.word  0")
                out("_prog8_entrypoint\t; assembly code starts here\n")
                out("\tjsr  c64utils.init_system")
            }
            options.output == OutputType.PRG -> {
                out("; ---- program without sys call ----")
                out("* = ${program.loadAddress.toHex()}\n")
                out("\tjsr  c64utils.init_system")
            }
            options.output == OutputType.RAW -> {
                out("; ---- raw assembler program ----")
                out("* = ${program.loadAddress.toHex()}\n")
            }
        }

        out("\tldx  #\$ff\t; init estack pointer")
        out("\tclc")
        out("\tjmp  main.start\t; jump to program entrypoint")
        out("")

        // the global list of all floating point constants for the whole program
        for(flt in globalFloatConsts) {
            val floatFill = makeFloatFill(Mflpt5.fromNumber(flt.key))
            out("${flt.value}\t.byte  $floatFill  ; float ${flt.key}")
        }
    }

    private fun block2asm(block: IntermediateProgram.ProgramBlock) {
        out("\n; ---- block: '${block.shortname}' ----")
        if(block.address!=null) {
            out(".cerror * > ${block.address?.toHex()}, 'block address overlaps by ', *-${block.address?.toHex()},' bytes'")
            out("* = ${block.address?.toHex()}")
        }
        out("${block.shortname}\t.proc\n")
        out("\n; constants/memdefs/kernel subroutines")
        memdefs2asm(block)
        out("\n; variables")
        vardecls2asm(block)
        out("")

        var skip = 0
        for(ins in block.instructions.withIndex()) {
            if(skip==0)
                skip = instr2asm(ins.index, ins.value, block)
            else
                skip--
        }
        out("\n\t.pend\n")
    }

    private fun memdefs2asm(block: IntermediateProgram.ProgramBlock) {
        for(m in block.integerConstants) {
            out("\t${m.key} = ${m.value.toHex()}")
        }
    }

    private fun vardecls2asm(block: IntermediateProgram.ProgramBlock) {
        val sortedVars = block.variables.toList().sortedBy { it.second.type }
        for (v in sortedVars) {
            when (v.second.type) {
                DataType.UBYTE -> out("${v.first}\t.byte  0")
                DataType.BYTE -> out("${v.first}\t.char  0")
                DataType.UWORD -> out("${v.first}\t.word  0")
                DataType.WORD -> out("${v.first}\t.sint  0")
                DataType.FLOAT -> out("${v.first}\t.fill  5  ; float")
                DataType.STR,
                DataType.STR_P,
                DataType.STR_S,
                DataType.STR_PS -> {
                    val rawStr = heap.get(v.second.heapId).str!!
                    val bytes = encodeStr(rawStr, v.second.type).map { "$" + it.toString(16).padStart(2, '0') }
                    out("${v.first}\t; ${v.second.type} \"$rawStr\"")
                    for (chunk in bytes.chunked(16))
                        out("\t.byte  " + chunk.joinToString())
                }
                DataType.ARRAY_UB, DataType.MATRIX_UB -> {
                    // unsigned integer byte array
                    val data = makeArrayFillDataUnsigned(v.second)
                    if (data.size <= 16)
                        out("${v.first}\t.byte  ${data.joinToString()}")
                    else {
                        out(v.first)
                        for (chunk in data.chunked(16))
                            out("\t.byte  " + chunk.joinToString())
                    }
                }
                DataType.ARRAY_B, DataType.MATRIX_B -> {
                    // signed integer byte array
                    val data = makeArrayFillDataSigned(v.second)
                    if (data.size <= 16)
                        out("${v.first}\t.char  ${data.joinToString()}")
                    else {
                        out(v.first)
                        for (chunk in data.chunked(16))
                            out("\t.char  " + chunk.joinToString())
                    }
                }
                DataType.ARRAY_UW -> {
                    // unsigned word array
                    val data = makeArrayFillDataUnsigned(v.second)
                    if (data.size <= 16)
                        out("${v.first}\t.word  ${data.joinToString()}")
                    else {
                        out(v.first)
                        for (chunk in data.chunked(16))
                            out("\t.word  " + chunk.joinToString())
                    }
                }
                DataType.ARRAY_W -> {
                    // signed word array
                    val data = makeArrayFillDataSigned(v.second)
                    if (data.size <= 16)
                        out("${v.first}\t.sint  ${data.joinToString()}")
                    else {
                        out(v.first)
                        for (chunk in data.chunked(16))
                            out("\t.sint  " + chunk.joinToString())
                    }
                }
                DataType.ARRAY_F -> {
                    // float array
                    val array = heap.get(v.second.heapId).doubleArray!!
                    val floatFills = array.map { makeFloatFill(Mflpt5.fromNumber(it)) }
                    out(v.first)
                    for(f in array.zip(floatFills))
                        out("\t.byte  ${f.second}  ; float ${f.first}")
                }
            }
        }
    }

    private fun encodeStr(str: String, dt: DataType): List<Short> {
        when(dt) {
            DataType.STR -> {
                val bytes = Petscii.encodePetscii(str, true)
                return bytes.plus(0)
            }
            DataType.STR_P -> {
                val result = listOf(str.length.toShort())
                val bytes = Petscii.encodePetscii(str, true)
                return result.plus(bytes)
            }
            DataType.STR_S -> {
                val bytes = Petscii.encodeScreencode(str, true)
                return bytes.plus(0)
            }
            DataType.STR_PS -> {
                val result = listOf(str.length.toShort())
                val bytes = Petscii.encodeScreencode(str, true)
                return result.plus(bytes)
            }
            else -> throw AssemblyError("invalid str type")
        }
    }

    private fun makeArrayFillDataUnsigned(value: Value): List<String> {
        val array = heap.get(value.heapId).array!!
        return if (value.type == DataType.ARRAY_UB || value.type == DataType.ARRAY_UW || value.type == DataType.MATRIX_UB)
            array.map { "$"+it.toString(16).padStart(2, '0') }
        else
            throw AssemblyError("invalid array type")
    }

    private fun makeArrayFillDataSigned(value: Value): List<String> {
        val array = heap.get(value.heapId).array!!
        return if (value.type == DataType.ARRAY_B || value.type == DataType.ARRAY_W || value.type == DataType.MATRIX_B) {
            array.map {
                if(it>=0)
                    "$"+it.toString(16).padStart(2, '0')
                else
                    "-$"+abs(it).toString(16).padStart(2, '0')
            }
        }
        else throw AssemblyError("invalid array type")
    }

    private val registerStrings = setOf("A", "X", "Y", "AX", "AY", "XY")


    // note: to put stuff on the stack, we use Absolute,X  addressing mode which is 3 bytes / 4 cycles
    // possible space optimization is to use zeropage (indirect),Y  which is 2 bytes, but 5 cycles

    private fun pushByte(byte: Int) {
        out("\tlda  #${byte.toHex()}")
        pushByteA()
    }

    private fun pushByteA() {
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tdex")
    }

    private fun pushByteY() {
        out("\ttya")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tdex")
    }

    private fun replaceByteA() {
        out("\tsta  ${(ESTACK_LO+1).toHex()},x")
    }

    private fun pushMemByte(address: Int) {
        out("\tlda  ${address.toHex()}")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tdex")
    }

    private fun pushVarByte(name: String) {
        out("\tlda  $name")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tdex")
    }

    private fun pushWord(word: Int) {
        out("\tlda  #<${word.toHex()}")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tlda  #<${word.toHex()}")
        out("\tsta  ${ESTACK_HI.toHex()},x")
        out("\tdex")
    }

    private fun pushWordAY() {
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\ttya")
        out("\tsta  ${ESTACK_HI.toHex()},x")
        out("\tdex")
    }

    private fun replaceWordAY() {
        out("\tsta  ${(ESTACK_LO+1).toHex()},x")
        out("\ttya")
        out("\tsta  ${(ESTACK_HI+1).toHex()},x")
    }

    private fun pushMemWord(address: Int) {
        out("\tlda  ${address.toHex()}")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tlda  ${(address+1).toHex()}")
        out("\tsta  ${ESTACK_HI.toHex()},x")
        out("\tdex")
    }

    private fun pushVarWord(name: String) {
        out("\tlda  $name")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tlda  $name+1")
        out("\tsta  ${ESTACK_HI.toHex()},x")
        out("\tdex")
    }

    private fun pushFloat(label: String) {
        // todo this is too large for inline, make a subroutine
        out("\tlda  $label")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tlda  $label+1")
        out("\tsta  ${ESTACK_HI.toHex()},x")
        out("\tdex")
        out("\tlda  $label+2")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tlda  $label+3")
        out("\tsta  ${ESTACK_HI.toHex()},x")
        out("\tdex")
        out("\tlda  $label+4")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        // 6th byte is not used for floats
        out("\tdex")
    }

    private fun popByteA() {
        // for operations that remove a value from the stack
        out("\tinx")
        out("\tlda  ${ESTACK_LO.toHex()},x")
    }

    private fun popByteY() {
        // for operations that remove a value from the stack
        out("\tinx")
        out("\tldy  ${ESTACK_LO.toHex()},x")
    }

    private fun peekByteA() {
        // for operations that modify a value on the stack
        out("\tlda  ${(ESTACK_LO+1).toHex()},x")
    }

    private fun peekByte2A() {
        // for operations that modify a value on the stack, 1 under the top
        out("\tlda  ${(ESTACK_LO+2).toHex()},x")
    }

    private fun popWordAY() {
        // for operations that remove a value from the stack
        out("\ninx")
        out("\tlda  ${ESTACK_LO.toHex()},x")
        out("\tldy  ${ESTACK_HI.toHex()},x")
    }

    private fun peekWordAY() {
        // for operations that modify a value on the stack
        out("\tlda  ${(ESTACK_LO+1).toHex()},x")
        out("\tldy  ${(ESTACK_HI+1).toHex()},x")
    }

    private fun peekWord2AY() {
        // for operations that modify a value on the stack, 1 under the top
        out("\tlda  ${(ESTACK_LO+2).toHex()},x")
        out("\tldy  ${(ESTACK_HI+2).toHex()},x")
    }

    private fun instr2asm(insIdx: Int, ins: Instruction, block: IntermediateProgram.ProgramBlock): Int {
        if(ins is LabelInstr) {
            if(ins.name==block.shortname)
                return 0
            if(ins.name.startsWith("${block.shortname}."))
                out(ins.name.substring(block.shortname.length+1))
            else
                out(ins.name)
            return 0
        }
        when(ins.opcode) {
            Opcode.LINE -> out("\t; src line: ${ins.callLabel}")
            Opcode.NOP -> out("\tnop")      // shouldn't be present anymore though
            Opcode.TERMINATE -> out("\tbrk\t; terminate!")
            Opcode.SEC -> out("\tsec")
            Opcode.CLC -> out("\tclc")
            Opcode.SEI -> out("\tsei")
            Opcode.CLI -> out("\tcli")
            Opcode.JUMP -> out("\tjmp  ${ins.callLabel}")
            Opcode.CALL -> out("\tjsr  ${ins.callLabel}")
            Opcode.RETURN -> out("\trts")       // todo is return really this simple?
            Opcode.B2UB -> {}       // is a no-op, just carry on with the byte as-is
            Opcode.UB2B -> {}       // is a no-op, just carry on with the byte as-is
            Opcode.RSAVE -> out("\tphp\n\tpha\n\ttxa\n\tpha\n\ttya\n\tpha")
            Opcode.RRESTORE -> out("\tpla\n\ttay\n\tpla\n\ttax\n\tpla\n\tplp")
            Opcode.DISCARD_BYTE -> out("\tinx")                     // remove 1 (2) bytes from stack
            Opcode.DISCARD_WORD -> out("\tinx")                     // remove 2 bytes from stack
            Opcode.DISCARD_FLOAT -> out("\tinx\n\tinx\n\tinx")      // remove 5 (6) bytes from stack
            Opcode.INLINE_ASSEMBLY -> out(ins.callLabel)        // All of the inline assembly is stored in the calllabel property.
            Opcode.COPY_VAR_BYTE -> {
                when {
                    ins.callLabel2 in registerStrings -> {
                        if(ins.callLabel in registerStrings) {
                            // copying register -> register
                            when {
                                ins.callLabel == "A" -> out("\tta${ins.callLabel2!!.toLowerCase()}")
                                ins.callLabel == "X" ->
                                    if (ins.callLabel2 == "Y")
                                        out("\ttxa\n\ttay")    // 6502 doesn't have txy
                                    else
                                        out("\ttxa")
                                ins.callLabel == "Y" ->
                                    if (ins.callLabel2 == "X")
                                        out("\ttya\n\ttax")   // 6502 doesn't have tyx
                                    else
                                        out("\ttya")
                            }
                            return 0
                        }
                        // var -> reg
                        out("\tld${ins.callLabel2!!.toLowerCase()}  ${ins.callLabel}")
                    }
                    ins.callLabel in registerStrings ->
                        // reg -> var
                        out("\tst${ins.callLabel!!.toLowerCase()}  ${ins.callLabel2}")
                    else ->
                        // var -> var
                        out("\tlda  ${ins.callLabel}\n\tsta  ${ins.callLabel2}")
                }
            }
            Opcode.COPY_VAR_WORD -> {
                when {
                    ins.callLabel2 in registerStrings -> {
                        if(ins.callLabel in registerStrings) {
                            // copying registerpair -> registerpair
                            when {
                                ins.callLabel == "AX" -> when (ins.callLabel2) {
                                    "AY" -> out("\ttxy")
                                    "XY" -> out("\tpha\n\ttxa\n\ttay\n\tpla\n\ttax")
                                }
                                ins.callLabel == "AY" -> when (ins.callLabel2) {
                                    "AX" -> out("\tpha\n\ttya\n\ttax\n\tpla")
                                    "XY" -> out("\ttax")
                                }
                                ins.callLabel == "XY" -> when (ins.callLabel2) {
                                    "AX" -> out("\ttxa\n\tpha\n\ttya\n\ttax\n\tpla")
                                    "AY" -> out("\ttxa")
                                }
                            }
                            return 0
                        }
                        // wvar  -> regpair
                        val regpair = ins.callLabel2!!.toLowerCase()
                        out("\tld${regpair[0]}  ${ins.callLabel}")
                        out("\tld${regpair[1]}  ${ins.callLabel}+1")
                    }
                    ins.callLabel in registerStrings -> {
                        // regpair->wvar
                        val regpair = ins.callLabel!!.toLowerCase()
                        out("\tst${regpair[0]}  ${ins.callLabel2}")
                        out("\tst${regpair[1]}  ${ins.callLabel2}+1")
                    }
                    else -> {
                        // wvar->wvar
                        out("\tlda  ${ins.callLabel}\n\tsta  ${ins.callLabel2}")
                        out("\tlda  ${ins.callLabel}+1\n\tsta  ${ins.callLabel2}+1")
                    }
                }
            }
            Opcode.PUSH_BYTE -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_BYTE)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_BYTE) {
                    if(nextIns.callLabel in registerStrings) {
                        // load a register with constant value
                        out("\tld${nextIns.callLabel!!.toLowerCase()}  #${ins.arg!!.integerValue().toHex()}")
                        return 1    // skip 1
                    }
                    // load a variable with a constant value
                    out("\tlda  #${ins.arg!!.integerValue().toHex()}")
                    out("\tsta  ${nextIns.callLabel}")
                    return 1    // skip 1
                }
                if(nextIns.opcode==Opcode.POP_MEM_B || nextIns.opcode==Opcode.POP_MEM_UB) {
                    // memory location = constant value
                    out("\tlda  #${ins.arg!!.integerValue().toHex()}")
                    out("\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    return 1    // skip 1
                }
                // byte onto stack
                pushByte(ins.arg!!.integerValue())
            }
            Opcode.PUSH_MEM_UB, Opcode.PUSH_MEM_B -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_BYTE)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_BYTE) {
                    if(nextIns.callLabel in registerStrings) {
                        // load a register with memory location
                        out("\tld${nextIns.callLabel!!.toLowerCase()}  ${ins.arg!!.integerValue().toHex()}")
                        return 1    // skip 1
                    }
                    // load var with mem b
                    out("\tlda  ${ins.arg!!.integerValue().toHex()}\n\tsta  ${nextIns.callLabel}")
                    return 1    // skip 1
                }
                if(nextIns.opcode==Opcode.POP_MEM_B || nextIns.opcode==Opcode.POP_MEM_UB) {
                    // copy byte from mem -> mem
                    out("\tlda  ${ins.arg!!.integerValue().toHex()}\n\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    return 1    // skip 1
                }
                // byte from memory onto stack
                pushMemByte(ins.arg!!.integerValue())
            }
            Opcode.PUSH_VAR_BYTE -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_BYTE)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_BYTE)
                    throw CompilerException("push var+pop var should have been replaced by copy var")
                if(nextIns.opcode==Opcode.POP_MEM_B || nextIns.opcode==Opcode.POP_MEM_UB) {
                    // copy byte from var -> mem
                    out("\tlda  ${ins.callLabel}\n\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    return 1    // skip 1
                }
                // byte from variable onto stack
                when(ins.callLabel) {
                    "A" -> pushByteA()
                    "X" -> throw CompilerException("makes no sense to push X it's used as a stack pointer itself")
                    "Y" -> pushByteY()
                    else -> pushVarByte(ins.callLabel!!)
                }
            }
            Opcode.PUSH_WORD -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_WORD)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_WORD) {
                    val value = ins.arg!!.integerValue()
                    if(nextIns.callLabel in registerStrings) {
                        // we load a register (AX, AY, XY) with constant value
                        val regs = nextIns.callLabel!!.toLowerCase()
                        out("\tld${regs[0]}  #<${value.toHex()}")
                        out("\tld${regs[1]}  #>${value.toHex()}")
                        return 1    // skip 1
                    }
                    // load a word variable with a constant value
                    out("\tlda  #<${value.toHex()}")
                    out("\tsta  ${nextIns.callLabel}")
                    out("\tlda  #>${value.toHex()}")
                    out("\tsta  ${nextIns.callLabel}+1")
                    return 1    // skip 1
                }
                if(nextIns.opcode==Opcode.POP_MEM_W || nextIns.opcode==Opcode.POP_MEM_UW) {
                    // we're loading a word into memory
                    out("\tlda  #<${ins.arg!!.integerValue().toHex()}")
                    out("\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    out("\tlda  #>${ins.arg.integerValue().toHex()}")
                    out("\tsta  ${(nextIns.arg.integerValue()+1).toHex()}")
                    return 1    // skip 1
                }
                pushWord(ins.arg!!.integerValue())
            }
            Opcode.PUSH_MEM_UW, Opcode.PUSH_MEM_W -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_WORD)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_WORD) {
                    if(nextIns.callLabel in registerStrings) {
                        // load a register (AX, AY, XY) with word from memory
                        val regs = nextIns.callLabel!!.toLowerCase()
                        val value = ins.arg!!.integerValue()
                        out("\tld${regs[0]}  ${value.toHex()}")
                        out("\tld${regs[1]}  ${(value + 1).toHex()}")
                        return 1    // skip 1
                    }
                    // load var with mem word
                    out("\tlda  ${ins.arg!!.integerValue().toHex()}")
                    out("\tsta  ${nextIns.callLabel}")
                    out("\tlda  ${(ins.arg.integerValue()+1).toHex()}")
                    out("\tsta  ${nextIns.callLabel}+1")
                    return 1    // skip 1
                }
                if(nextIns.opcode==Opcode.POP_MEM_W || nextIns.opcode==Opcode.POP_MEM_UW) {
                    // copy word mem->mem
                    out("\tlda  ${ins.arg!!.integerValue().toHex()}")
                    out("\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    out("\tlda  ${(ins.arg.integerValue()+1).toHex()}")
                    out("\tsta  ${(nextIns.arg.integerValue()+1).toHex()}")
                    return 1    // skip 1
                }
                // word from memory onto stack
                pushMemWord(ins.arg!!.integerValue())
            }
            Opcode.PUSH_VAR_WORD -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_FLOAT)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_WORD)
                    throw CompilerException("push var+pop var should have been replaced by copy var")
                if(nextIns.opcode==Opcode.POP_MEM_W || nextIns.opcode==Opcode.POP_MEM_UW) {
                    // copy word from var -> mem
                    out("\tlda  ${ins.callLabel}\n\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    return 1    // skip 1
                }
                // word from memory onto stack
                when(ins.callLabel) {
                    "AX" -> TODO()
                    "AY" -> TODO()
                    "XY" -> TODO()
                    else -> pushVarWord(ins.callLabel!!)
                }
            }
            Opcode.PUSH_FLOAT -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_FLOAT)
                    throw CompilerException("discard after push should have been removed")
                if(!options.floats)
                    throw CompilerException("floats not enabled")
                val float = ins.arg!!.numericValue().toDouble()
                val label = globalFloatConsts[float]!!
                if(nextIns.opcode==Opcode.POP_MEM_FLOAT) {
                    // set a float in memory to a constant float value
                    copyFloat(label, nextIns.arg!!.integerValue().toHex())
                    return 1
                } else if(nextIns.opcode==Opcode.POP_VAR_FLOAT) {
                    // set a variable to a constant float value
                    copyFloat(label, nextIns.callLabel!!)
                    return 1
                }
                pushFloat(label)
            }
            Opcode.PUSH_VAR_FLOAT -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_FLOAT)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_FLOAT)
                    throw CompilerException("push var+pop var should have been replaced by copy var")
                if(!options.floats)
                    throw CompilerException("floats not enabled")
                if(nextIns.opcode==Opcode.POP_MEM_FLOAT) {
                    copyFloat(ins.callLabel!!, nextIns.arg!!.integerValue().toHex())        // copy var float to memory
                    return 1
                }
                pushFloat(ins.callLabel!!)
            }
            Opcode.PUSH_MEM_FLOAT -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_FLOAT)
                    throw CompilerException("discard after push should have been removed")
                if(!options.floats)
                    throw CompilerException("floats not enabled")
                if(nextIns.opcode==Opcode.POP_VAR_FLOAT) {
                    copyFloat(ins.arg!!.integerValue().toHex(), nextIns.callLabel!!)        // copy memory float to var
                    return 1
                }
                if(nextIns.opcode==Opcode.POP_MEM_FLOAT) {
                    copyFloat(ins.arg!!.integerValue().toHex(), nextIns.arg!!.integerValue().toHex())        // copy memory float to memory float
                    return 1
                }
                pushFloat(ins.arg!!.integerValue().toHex())
            }
            Opcode.INC_VAR_UB, Opcode.INC_VAR_B -> {
                when(ins.callLabel) {
                    "A" -> out("\tclc\n\tadc  #1")
                    "X" -> out("\tinx")
                    "Y" -> out("\tiny")
                    else -> out("\tinc  ${ins.callLabel}")
                }
            }
            Opcode.INC_VAR_UW -> {
                when(ins.callLabel) {
                    "AX" -> {
                        out("\tclc\n\tadc  #1")
                        out("\tbne  +")
                        out("\tinx")
                        out("+")
                    }
                    "AY" -> {
                        out("\tclc\n\tadc  #1")
                        out("\tbne  +")
                        out("\tiny")
                        out("+")
                    }
                    "XY" -> {
                        out("\tinx")
                        out("\tbne  +")
                        out("\tiny")
                        out("+")
                    }
                    else -> TODO("inc_var_uw $ins")
                }
            }
            Opcode.DEC_VAR_UB, Opcode.DEC_VAR_B -> {
                when(ins.callLabel) {
                    "A" -> out("\tsec\n\tsbc  #1")
                    "X" -> out("\tdex")
                    "Y" -> out("\tdey")
                    else -> out("\tdec  ${ins.callLabel}")
                }
            }
            Opcode.ADD_UB, Opcode.ADD_B -> {
                peekByte2A()
                out("\tclc\n\tadc  ${(ESTACK_LO+1).toHex()},x")
                out("\tinx")
                replaceByteA()
            }
            Opcode.SUB_UB, Opcode.SUB_B -> {
                peekByte2A()
                out("\tsec\n\tsbc  ${(ESTACK_LO+1).toHex()},x")
                out("\tinx")
                replaceByteA()
            }
            Opcode.POP_MEM_UB, Opcode.POP_MEM_B -> {
                popByteA()
                out("\tsta  ${ins.arg!!.integerValue().toHex()}")
            }
            Opcode.POP_VAR_BYTE -> {
                when(ins.callLabel) {
                    "A" -> popByteA()
                    "X" -> throw CompilerException("makes no sense to pop X it's used as a stack pointer itself")
                    "Y" -> popByteY()
                    else -> {
                        popByteA()
                        out("\tsta  ${ins.callLabel}")
                    }
                }
            }
            Opcode.POP_VAR_WORD -> {
                when(ins.callLabel) {
                    "AX" -> throw CompilerException("makes no sense to pop X it's used as a stack pointer itself")
                    "AY" -> TODO()
                    "XY" -> throw CompilerException("makes no sense to pop X it's used as a stack pointer itself")
                    else -> {
                        popWordAY()
                        out("\tsta  ${ins.callLabel}")
                        out("\tsty  ${ins.callLabel}+1")
                    }
                }
            }
            Opcode.DEC_VAR_UW -> {
                when(ins.callLabel) {
                    "AX" -> {
                        out("\tcmp  #0")
                        out("\tbne  +")
                        out("\tdex")
                        out("+\tsec\n\tsbc  #1")
                    }
                    "AY" -> {
                        out("\tcmp  #0")
                        out("\tbne  +")
                        out("\tdey")
                        out("+\tsec\n\tsbc  #1")
                    }
                    "XY" -> {
                        out("\ttxa")
                        out("\tbne  +")
                        out("\tdey")
                        out("+\tdex")
                    }
                    else -> TODO("dec_var_uw $ins")
                }
            }
            Opcode.NEG_B -> {
                peekByteA()
                out("\teor  #\$ff")
                out("\tsec\n\tadc  #0")
                replaceByteA()
            }
            Opcode.INV_BYTE -> {
                peekByteA()
                out("\teor  #\$ff")
                replaceByteA()
            }
            Opcode.INV_WORD -> {
                out("\tlda  ${(ESTACK_LO+1).toHex()},x")
                out("\teor  #\$ff")
                out("\tlda  ${(ESTACK_HI+1).toHex()},x")
                out("\teor  #\$ff")
                out("\tsta  ${(ESTACK_LO+1).toHex()},x")
                out("\tsta  ${(ESTACK_HI+1).toHex()},x")
            }
            Opcode.NOT_BYTE -> {
                peekByteA()
                out("\tbeq  +")
                out("\tlda  #0")
                out("\tbeq  ++")
                out("+\tlda  #1")
                out("+")
                replaceByteA()
            }
            Opcode.NOT_WORD -> {
                out("\tlda  ${(ESTACK_LO+1).toHex()},x")
                out("\tora  ${(ESTACK_HI+1).toHex()},x")
                out("\tbeq  +")
                out("\tlda  #0")
                out("\tbeq  ++")
                out("+\tlda  #1")
                out("+\tsta  ${(ESTACK_LO+1).toHex()},x")
                out("\tsta  ${(ESTACK_HI+1).toHex()},x")
            }

            else-> TODO("asm for $ins")
//            Opcode.POP_MEM_W -> TODO()
//            Opcode.POP_MEM_UW -> TODO()
//            Opcode.POP_MEM_FLOAT -> TODO()
//            Opcode.POP_VAR_WORD -> TODO()
//            Opcode.POP_VAR_FLOAT -> TODO()
//            Opcode.COPY_VAR_FLOAT -> TODO()
//            Opcode.INC_VAR_W -> TODO()
//            Opcode.INC_VAR_F -> TODO()
//            Opcode.DEC_VAR_W -> TODO()
//            Opcode.DEC_VAR_F -> TODO()
//            Opcode.ADD_UW -> TODO()
//            Opcode.ADD_W -> TODO()
//            Opcode.ADD_F -> TODO()
//            Opcode.SUB_UW -> TODO()
//            Opcode.SUB_W -> TODO()
//            Opcode.SUB_F -> TODO()
//            Opcode.MUL_UB -> TODO()
//            Opcode.MUL_B -> TODO()
//            Opcode.MUL_UW -> TODO()
//            Opcode.MUL_W -> TODO()
//            Opcode.MUL_F -> TODO()
//            Opcode.DIV_UB -> TODO()
//            Opcode.DIV_B -> TODO()
//            Opcode.DIV_UW -> TODO()
//            Opcode.DIV_W -> TODO()
//            Opcode.DIV_F -> TODO()
//            Opcode.FLOORDIV_UB -> TODO()
//            Opcode.FLOORDIV_B -> TODO()
//            Opcode.FLOORDIV_UW -> TODO()
//            Opcode.FLOORDIV_W -> TODO()
//            Opcode.FLOORDIV_F -> TODO()
//            Opcode.REMAINDER_UB -> TODO()
//            Opcode.REMAINDER_B -> TODO()
//            Opcode.REMAINDER_UW -> TODO()
//            Opcode.REMAINDER_W -> TODO()
//            Opcode.REMAINDER_F -> TODO()
//            Opcode.POW_UB -> TODO()
//            Opcode.POW_B -> TODO()
//            Opcode.POW_UW -> TODO()
//            Opcode.POW_W -> TODO()
//            Opcode.POW_F -> TODO()
//            Opcode.NEG_W -> TODO()
//            Opcode.NEG_F -> TODO()
//            Opcode.SHL_BYTE -> TODO()
//            Opcode.SHL_WORD -> TODO()
//            Opcode.SHL_MEM_BYTE -> TODO()
//            Opcode.SHL_MEM_WORD -> TODO()
//            Opcode.SHL_VAR_BYTE -> TODO()
//            Opcode.SHL_VAR_WORD -> TODO()
//            Opcode.SHR_BYTE -> TODO()
//            Opcode.SHR_WORD -> TODO()
//            Opcode.SHR_MEM_BYTE -> TODO()
//            Opcode.SHR_MEM_WORD -> TODO()
//            Opcode.SHR_VAR_BYTE -> TODO()
//            Opcode.SHR_VAR_WORD -> TODO()
//            Opcode.ROL_BYTE -> TODO()
//            Opcode.ROL_WORD -> TODO()
//            Opcode.ROL_MEM_BYTE -> TODO()
//            Opcode.ROL_MEM_WORD -> TODO()
//            Opcode.ROL_VAR_BYTE -> TODO()
//            Opcode.ROL_VAR_WORD -> TODO()
//            Opcode.ROR_BYTE -> TODO()
//            Opcode.ROR_WORD -> TODO()
//            Opcode.ROR_MEM_BYTE -> TODO()
//            Opcode.ROR_MEM_WORD -> TODO()
//            Opcode.ROR_VAR_BYTE -> TODO()
//            Opcode.ROR_VAR_WORD -> TODO()
//            Opcode.ROL2_BYTE -> TODO()
//            Opcode.ROL2_WORD -> TODO()
//            Opcode.ROL2_MEM_BYTE -> TODO()
//            Opcode.ROL2_MEM_WORD -> TODO()
//            Opcode.ROL2_VAR_BYTE -> TODO()
//            Opcode.ROL2_VAR_WORD -> TODO()
//            Opcode.ROR2_BYTE -> TODO()
//            Opcode.ROR2_WORD -> TODO()
//            Opcode.ROR2_MEM_BYTE -> TODO()
//            Opcode.ROR2_MEM_WORD -> TODO()
//            Opcode.ROR2_VAR_BYTE -> TODO()
//            Opcode.ROR2_VAR_WORD -> TODO()
//            Opcode.BITAND_BYTE -> TODO()
//            Opcode.BITAND_WORD -> TODO()
//            Opcode.BITOR_BYTE -> TODO()
//            Opcode.BITOR_WORD -> TODO()
//            Opcode.BITXOR_BYTE -> TODO()
//            Opcode.BITXOR_WORD -> TODO()
//            Opcode.LSB -> TODO()
//            Opcode.MSB -> TODO()
//            Opcode.B2WORD -> TODO()
//            Opcode.UB2UWORD -> TODO()
//            Opcode.MSB2WORD -> TODO()
//            Opcode.B2FLOAT -> TODO()
//            Opcode.UB2FLOAT -> TODO()
//            Opcode.W2FLOAT -> TODO()
//            Opcode.UW2FLOAT -> TODO()
//            Opcode.AND_BYTE -> TODO()
//            Opcode.AND_WORD -> TODO()
//            Opcode.OR_BYTE -> TODO()
//            Opcode.OR_WORD -> TODO()
//            Opcode.XOR_BYTE -> TODO()
//            Opcode.XOR_WORD -> TODO()
//            Opcode.LESS_B -> TODO()
//            Opcode.LESS_UB -> TODO()
//            Opcode.LESS_W -> TODO()
//            Opcode.LESS_UW -> TODO()
//            Opcode.LESS_F -> TODO()
//            Opcode.GREATER_B -> TODO()
//            Opcode.GREATER_UB -> TODO()
//            Opcode.GREATER_W -> TODO()
//            Opcode.GREATER_UW -> TODO()
//            Opcode.GREATER_F -> TODO()
//            Opcode.LESSEQ_B -> TODO()
//            Opcode.LESSEQ_UB -> TODO()
//            Opcode.LESSEQ_W -> TODO()
//            Opcode.LESSEQ_UW -> TODO()
//            Opcode.LESSEQ_F -> TODO()
//            Opcode.GREATEREQ_B -> TODO()
//            Opcode.GREATEREQ_UB -> TODO()
//            Opcode.GREATEREQ_W -> TODO()
//            Opcode.GREATEREQ_UW -> TODO()
//            Opcode.GREATEREQ_F -> TODO()
//            Opcode.EQUAL_BYTE -> TODO()
//            Opcode.EQUAL_WORD -> TODO()
//            Opcode.EQUAL_F -> TODO()
//            Opcode.NOTEQUAL_BYTE -> TODO()
//            Opcode.NOTEQUAL_WORD -> TODO()
//            Opcode.NOTEQUAL_F -> TODO()
//            Opcode.READ_INDEXED_VAR_BYTE -> TODO()
//            Opcode.READ_INDEXED_VAR_WORD -> TODO()
//            Opcode.READ_INDEXED_VAR_FLOAT -> TODO()
//            Opcode.WRITE_INDEXED_VAR_BYTE -> TODO()
//            Opcode.WRITE_INDEXED_VAR_WORD -> TODO()
//            Opcode.WRITE_INDEXED_VAR_FLOAT -> TODO()
//            Opcode.BCS -> TODO()
//            Opcode.BCC -> TODO()
//            Opcode.BZ -> TODO()
//            Opcode.BNZ -> TODO()
//            Opcode.BNEG -> TODO()
//            Opcode.BPOS -> TODO()
//            Opcode.SYSCALL -> TODO()
//            Opcode.BREAKPOINT -> TODO()
        }
        return 0
    }
}
