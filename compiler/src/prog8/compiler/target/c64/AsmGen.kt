package prog8.compiler.target.c64

import prog8.compiler.*
import prog8.compiler.intermediate.Instruction
import prog8.compiler.intermediate.IntermediateProgram
import prog8.compiler.intermediate.LabelInstr
import prog8.compiler.intermediate.Opcode
import java.io.File
import java.util.*


class AssemblyError(msg: String) : RuntimeException(msg)


class AsmGen(val options: CompilationOptions) {
    fun compileToAssembly(program: IntermediateProgram): AssemblyProgram {
        println("\nGenerating assembly code from intermediate code... ")
        // todo generate 6502 assembly
        val out = File("${program.name}.asm").printWriter()
        out.use {
            header(out::println, program)
            for(block in program.blocks)
                block2asm(out::println, block)
        }

        return AssemblyProgram(program.name)
    }

    private fun header(out: (String)->Unit, program: IntermediateProgram) {
        val ourName = this.javaClass.name
        out("; 6502 assembly code for '${program.name}'")
        out("; generated by $ourName on ${Date()}")
        out("; assembler syntax is for the 64tasm cross-assembler")
        out("; output options: output=${options.output} launcher=${options.launcher} zp=${options.zeropage}")
        out("\n.cpu  '6502'\n.enc  'none'\n")

        if(program.loadAddress==0)   // fix load address
            program.loadAddress = if(options.launcher==LauncherType.BASIC) BASIC_LOAD_ADDRESS else RAW_LOAD_ADDRESS

        when {
            options.launcher == LauncherType.BASIC -> {
                if (program.loadAddress != 0x0801)
                    throw AssemblyError("BASIC output must have load address $0801")
                out("; ---- basic program with sys call ----")
                out("* = ${program.loadAddress.toHex()}")
                val year = Calendar.getInstance().get(Calendar.YEAR)
                out("\t.word  (+), $year")
                out("\t.null  $9e, format(' %d ', _prog8_entrypoint), $3a, $8f, ' prog8 by idj'")
                out("+\t.word  0")
                out("_prog8_entrypoint\t; assembly code starts here\n")
            }
            options.output == OutputType.PRG -> {
                out("; ---- program without sys call ----")
                out("* = ${program.loadAddress.toHex()}\n")
            }
            options.output == OutputType.RAW -> {
                out("; ---- raw assembler program ----")
                out("* = ${program.loadAddress.toHex()}\n")
            }
        }

        // call the init methods of each block and then jump to the main.start entrypoint
        out("\t; initialize all blocks(reset vars)")
        // todo zeropage if it's there
        for(block in program.blocks)
            out("\tjsr  ${block.scopedname}._prog8_init")
        out("\tlda  #0")
        out("\ttay")
        out("\ttax")
        out("\tdex\t; init estack pointer to \$ff")
        out("\tclc")
        out("\tjmp  main.start\t; jump to program entrypoint")
    }

    private fun block2asm(out: (String)->Unit, block: IntermediateProgram.ProgramBlock) {
        out("\n; ---- block: '${block.shortname}' ----")
        if(block.address!=null) {
            out(".cerror * > ${block.address?.toHex()}, 'block address overlaps by ', *-${block.address?.toHex()},' bytes'")
            out("* = ${block.address?.toHex()}")
        }
        out("${block.shortname}\t.proc\n")

        // init the variables
        out("_prog8_init\t; (re)set vars to initial values")
        // todo init vars

        var skip = 0
        for(ins in block.instructions.withIndex()) {
            if(skip==0)
                skip = ins2asm(out, ins.index, ins.value, block)
            else
                skip--
        }
        out("\n\t.pend\n")
    }

    private val registerStrings = setOf("A", "X", "Y", "AX", "AY", "XY")


    // note: to put stuff on the stack, we use Absolute,X  addressing mode which is 3 bytes / 4 cycles
    // possible space optimization is to use zeropage (indirect),Y  which is 2 bytes, but 5 cycles

    private fun pushByte(byte: Int, out: (String) -> Unit) {
        out("\tlda  #${byte.toHex()}")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tdex")
    }

    private fun pushMemByte(address: Int, out: (String) -> Unit) {
        out("\tlda  ${address.toHex()}")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tdex")
    }

    private fun pushVarByte(name: String, out: (String) -> Unit) {
        out("\tlda  $name")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tdex")
    }

    private fun pushWord(word: Int, out: (String) -> Unit) {
        out("\tlda  #<${word.toHex()}")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tlda  #>${word.toHex()}")
        out("\tsta  ${ESTACK_HI.toHex()},x")
        out("\tdex")
    }

    private fun pushMemWord(address: Int, out: (String) -> Unit) {
        out("\tlda  ${address.toHex()}")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tlda  ${(address+1).toHex()}")
        out("\tsta  ${ESTACK_HI.toHex()},x")
        out("\tdex")
    }

    private fun pushVarWord(name: String, out: (String) -> Unit) {
        out("\tlda  $name")
        out("\tsta  ${ESTACK_LO.toHex()},x")
        out("\tlda  $name+1")
        out("\tsta  ${ESTACK_HI.toHex()},x")
        out("\tdex")
    }

    private fun popByteA(out: (String) -> Unit) {
        out("\tinx")
        out("\tlda  ${ESTACK_LO.toHex()},x")
    }

    private fun popWordAY(out: (String) -> Unit) {
        out("\tinx")
        out("\tlda  ${ESTACK_LO.toHex()},x")
        out("\tldy  ${ESTACK_HI.toHex()},x")
    }

    private fun ins2asm(out: (String) -> Unit, insIdx: Int, ins: Instruction, block: IntermediateProgram.ProgramBlock): Int {
        if(ins is LabelInstr) {
            if(ins.name==block.shortname)
                return 0
            if(ins.name.startsWith("${block.shortname}."))
                out(ins.name.substring(block.shortname.length+1))
            else
                out(ins.name)
            return 0
        }
        when(ins.opcode) {
            Opcode.LINE -> out("\t; src line: ${ins.callLabel}")
            Opcode.NOP -> out("\tnop")      // shouldn't be present anymore though
            Opcode.TERMINATE -> out("\tbrk\t; terminate!")
            Opcode.SEC -> out("\tsec")
            Opcode.CLC -> out("\tclc")
            Opcode.SEI -> out("\tsei")
            Opcode.CLI -> out("\tcli")
            Opcode.RETURN -> out("\trts")       // todo is return really this simple?
            Opcode.B2UB -> {}       // is a no-op, just carry on with the byte as-is
            Opcode.UB2B -> {}       // is a no-op, just carry on with the byte as-is
            Opcode.RSAVE -> out("\tphp\n\tpha\n\ttxa\n\tpha\n\ttya\n\tpha")
            Opcode.RRESTORE -> out("\tpla\n\ttay\n\tpla\n\ttax\n\tpla\n\tplp")
            Opcode.DISCARD_BYTE -> out("\tinx")                     // remove 1 (2) bytes from stack
            Opcode.DISCARD_WORD -> out("\tinx")                     // remove 2 bytes from stack
            Opcode.DISCARD_FLOAT -> out("\tinx\n\tinx\n\tinx")      // remove 5 (6) bytes from stack
            Opcode.COPY_VAR_BYTE -> {
                when {
                    ins.callLabel2 in registerStrings -> {
                        if(ins.callLabel in registerStrings) {
                            // copying register -> register
                            when {
                                ins.callLabel == "A" -> out("\tta${ins.callLabel2!!.toLowerCase()}")
                                ins.callLabel == "X" ->
                                    if (ins.callLabel2 == "Y")
                                        out("\ttxa\n\ttay")    // 6502 doesn't have txy
                                    else
                                        out("\ttxa")
                                ins.callLabel == "Y" ->
                                    if (ins.callLabel2 == "X")
                                        out("\ttya\n\ttax")   // 6502 doesn't have tyx
                                    else
                                        out("\ttya")
                            }
                            return 0
                        }
                        // var -> reg
                        out("\tld${ins.callLabel2!!.toLowerCase()}  ${ins.callLabel}")
                    }
                    ins.callLabel in registerStrings ->
                        // reg -> var
                        out("\tst${ins.callLabel!!.toLowerCase()}  ${ins.callLabel2}")
                    else ->
                        // var -> var
                        out("\tlda  ${ins.callLabel}\n\tsta  ${ins.callLabel2}")
                }
            }
            Opcode.COPY_VAR_WORD -> {
                when {
                    ins.callLabel2 in registerStrings -> {
                        if(ins.callLabel in registerStrings) {
                            // copying registerpair -> registerpair
                            when {
                                ins.callLabel == "AX" -> when (ins.callLabel2) {
                                    "AY" -> out("\ttxy")
                                    "XY" -> out("\tpha\n\ttxa\n\ttay\n\tpla\n\ttax")
                                }
                                ins.callLabel == "AY" -> when (ins.callLabel2) {
                                    "AX" -> out("\tpha\n\ttya\n\ttax\n\tpla")
                                    "XY" -> out("\ttax")
                                }
                                ins.callLabel == "XY" -> when (ins.callLabel2) {
                                    "AX" -> out("\ttxa\n\tpha\n\ttya\n\ttax\n\tpla")
                                    "AY" -> out("\ttxa")
                                }
                            }
                            return 0
                        }
                        // wvar  -> regpair
                        val regpair = ins.callLabel2!!.toLowerCase()
                        out("\tld${regpair[0]}  ${ins.callLabel}")
                        out("\tld${regpair[1]}  ${ins.callLabel}+1")
                    }
                    ins.callLabel in registerStrings -> {
                        // regpair->wvar
                        val regpair = ins.callLabel!!.toLowerCase()
                        out("\tst${regpair[0]}  ${ins.callLabel2}")
                        out("\tst${regpair[1]}  ${ins.callLabel2}+1")
                    }
                    else -> {
                        // wvar->wvar
                        out("\tlda  ${ins.callLabel}\n\tsta  ${ins.callLabel2}")
                        out("\tlda  ${ins.callLabel}+1\n\tsta  ${ins.callLabel2}+1")
                    }
                }
            }
            Opcode.PUSH_BYTE -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_BYTE)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_BYTE) {
                    if(nextIns.callLabel in registerStrings) {
                        // load a register with constant value
                        out("\tld${nextIns.callLabel!!.toLowerCase()}  #${ins.arg!!.integerValue().toHex()}")
                        return 1    // skip 1
                    }
                    // load a variable with a constant value
                    out("\tlda  #${ins.arg!!.integerValue().toHex()}")
                    out("\tsta  ${nextIns.callLabel}")
                    return 1    // skip 1
                }
                if(nextIns.opcode==Opcode.POP_MEM_B || nextIns.opcode==Opcode.POP_MEM_UB) {
                    // memory location = constant value
                    out("\tlda  #${ins.arg!!.integerValue().toHex()}")
                    out("\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    return 1    // skip 1
                }
                // byte onto stack
                pushByte(ins.arg!!.integerValue(), out)
            }
            Opcode.PUSH_MEM_UB, Opcode.PUSH_MEM_B -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_BYTE)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_BYTE) {
                    if(nextIns.callLabel in registerStrings) {
                        // load a register with memory location
                        out("\tld${nextIns.callLabel!!.toLowerCase()}  ${ins.arg!!.integerValue().toHex()}")
                        return 1    // skip 1
                    }
                    // load var with mem b
                    out("\tlda  ${ins.arg!!.integerValue().toHex()}\n\tsta  ${nextIns.callLabel}")
                    return 1    // skip 1
                }
                if(nextIns.opcode==Opcode.POP_MEM_B || nextIns.opcode==Opcode.POP_MEM_UB) {
                    // copy byte from mem -> mem
                    out("\tlda  ${ins.arg!!.integerValue().toHex()}\n\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    return 1    // skip 1
                }
                // byte from memory onto stack
                pushMemByte(ins.arg!!.integerValue(), out)
            }
            Opcode.PUSH_VAR_BYTE -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_BYTE)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_BYTE)
                    throw CompilerException("push var+pop var should have been replaced by copy var")
                if(nextIns.opcode==Opcode.POP_MEM_B || nextIns.opcode==Opcode.POP_MEM_UB) {
                    // copy byte from var -> mem
                    out("\tlda  ${ins.callLabel}\n\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    return 1    // skip 1
                }
                // byte from variable onto stack
                pushVarByte(ins.callLabel!!, out)
            }
            Opcode.PUSH_WORD -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_WORD)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_WORD) {
                    val value = ins.arg!!.integerValue()
                    if(nextIns.callLabel in registerStrings) {
                        // we load a register (AX, AY, XY) with constant value
                        val regs = nextIns.callLabel!!.toLowerCase()
                        out("\tld${regs[0]}  #<${value.toHex()}")
                        out("\tld${regs[1]}  #>${value.toHex()}")
                        return 1    // skip 1
                    }
                    // load a word variable with a constant value
                    out("\tlda  #<${value.toHex()}")
                    out("\tsta  ${nextIns.callLabel}")
                    out("\tlda  #>${value.toHex()}")
                    out("\tsta  ${nextIns.callLabel}+1")
                    return 1    // skip 1
                }
                if(nextIns.opcode==Opcode.POP_MEM_W || nextIns.opcode==Opcode.POP_MEM_UW) {
                    // we're loading a word into memory
                    out("\tlda  #<${ins.arg!!.integerValue().toHex()}")
                    out("\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    out("\tlda  #>${ins.arg.integerValue().toHex()}")
                    out("\tsta  ${(nextIns.arg.integerValue()+1).toHex()}")
                    return 1    // skip 1
                }
                pushWord(ins.arg!!.integerValue(), out)
            }
            Opcode.PUSH_MEM_UW, Opcode.PUSH_MEM_W -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_WORD)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_WORD) {
                    if(nextIns.callLabel in registerStrings) {
                        // load a register (AX, AY, XY) with word from memory
                        val regs = nextIns.callLabel!!.toLowerCase()
                        val value = ins.arg!!.integerValue()
                        out("\tld${regs[0]}  ${value.toHex()}")
                        out("\tld${regs[1]}  ${(value + 1).toHex()}")
                        return 1    // skip 1
                    }
                    // load var with mem word
                    out("\tlda  ${ins.arg!!.integerValue().toHex()}")
                    out("\tsta  ${nextIns.callLabel}")
                    out("\tlda  ${(ins.arg.integerValue()+1).toHex()}")
                    out("\tsta  ${nextIns.callLabel}+1")
                    return 1    // skip 1
                }
                if(nextIns.opcode==Opcode.POP_MEM_W || nextIns.opcode==Opcode.POP_MEM_UW) {
                    // copy word mem->mem
                    out("\tlda  ${ins.arg!!.integerValue().toHex()}")
                    out("\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    out("\tlda  ${(ins.arg.integerValue()+1).toHex()}")
                    out("\tsta  ${(nextIns.arg.integerValue()+1).toHex()}")
                    return 1    // skip 1
                }
                // word from memory onto stack
                pushMemWord(ins.arg!!.integerValue(), out)
            }
            Opcode.PUSH_VAR_WORD -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_FLOAT)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_WORD)
                    throw CompilerException("push var+pop var should have been replaced by copy var")
                if(nextIns.opcode==Opcode.POP_MEM_W || nextIns.opcode==Opcode.POP_MEM_UW) {
                    // copy word from var -> mem
                    out("\tlda  ${ins.callLabel}\n\tsta  ${nextIns.arg!!.integerValue().toHex()}")
                    return 1    // skip 1
                }
                // word from memory onto stack
                pushVarWord(ins.callLabel!!, out)
            }
            Opcode.PUSH_FLOAT -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_FLOAT)
                    throw CompilerException("discard after push should have been removed")
                if(!options.floats)
                    throw CompilerException("floats not enabled")
                TODO("push float")
            }
            Opcode.PUSH_VAR_FLOAT -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_FLOAT)
                    throw CompilerException("discard after push should have been removed")
                if(nextIns.opcode==Opcode.POP_VAR_FLOAT)
                    throw CompilerException("push var+pop var should have been replaced by copy var")
                if(!options.floats)
                    throw CompilerException("floats not enabled")
                TODO("push var float")
            }
            Opcode.PUSH_MEM_FLOAT -> {
                val nextIns = block.getIns(insIdx+1)
                if(nextIns==Opcode.DISCARD_FLOAT)
                    throw CompilerException("discard after push should have been removed")
                if(!options.floats)
                    throw CompilerException("floats not enabled")
                TODO("push mem float")
            }
            else-> TODO("asm for $ins")
//            Opcode.POP_MEM_B -> TODO()
//            Opcode.POP_MEM_UB -> TODO()
//            Opcode.POP_MEM_W -> TODO()
//            Opcode.POP_MEM_UW -> TODO()
//            Opcode.POP_MEM_FLOAT -> TODO()
//            Opcode.POP_VAR_BYTE -> TODO()
//            Opcode.POP_VAR_WORD -> TODO()
//            Opcode.POP_VAR_FLOAT -> TODO()
//            Opcode.COPY_VAR_FLOAT -> TODO()
//            Opcode.INC_B -> TODO()
//            Opcode.INC_UB -> TODO()
//            Opcode.INC_W -> TODO()
//            Opcode.INC_UW -> TODO()
//            Opcode.INC_F -> TODO()
//            Opcode.INC_VAR_B -> TODO()
//            Opcode.INC_VAR_UB -> TODO()
//            Opcode.INC_VAR_W -> TODO()
//            Opcode.INC_VAR_UW -> TODO()
//            Opcode.INC_VAR_F -> TODO()
//            Opcode.DEC_B -> TODO()
//            Opcode.DEC_UB -> TODO()
//            Opcode.DEC_W -> TODO()
//            Opcode.DEC_UW -> TODO()
//            Opcode.DEC_F -> TODO()
//            Opcode.DEC_VAR_B -> TODO()
//            Opcode.DEC_VAR_UB -> TODO()
//            Opcode.DEC_VAR_W -> TODO()
//            Opcode.DEC_VAR_UW -> TODO()
//            Opcode.DEC_VAR_F -> TODO()
//            Opcode.ADD_UB -> TODO()
//            Opcode.ADD_B -> TODO()
//            Opcode.ADD_UW -> TODO()
//            Opcode.ADD_W -> TODO()
//            Opcode.ADD_F -> TODO()
//            Opcode.SUB_UB -> TODO()
//            Opcode.SUB_B -> TODO()
//            Opcode.SUB_UW -> TODO()
//            Opcode.SUB_W -> TODO()
//            Opcode.SUB_F -> TODO()
//            Opcode.MUL_UB -> TODO()
//            Opcode.MUL_B -> TODO()
//            Opcode.MUL_UW -> TODO()
//            Opcode.MUL_W -> TODO()
//            Opcode.MUL_F -> TODO()
//            Opcode.DIV_UB -> TODO()
//            Opcode.DIV_B -> TODO()
//            Opcode.DIV_UW -> TODO()
//            Opcode.DIV_W -> TODO()
//            Opcode.DIV_F -> TODO()
//            Opcode.FLOORDIV_UB -> TODO()
//            Opcode.FLOORDIV_B -> TODO()
//            Opcode.FLOORDIV_UW -> TODO()
//            Opcode.FLOORDIV_W -> TODO()
//            Opcode.FLOORDIV_F -> TODO()
//            Opcode.REMAINDER_UB -> TODO()
//            Opcode.REMAINDER_B -> TODO()
//            Opcode.REMAINDER_UW -> TODO()
//            Opcode.REMAINDER_W -> TODO()
//            Opcode.REMAINDER_F -> TODO()
//            Opcode.POW_UB -> TODO()
//            Opcode.POW_B -> TODO()
//            Opcode.POW_UW -> TODO()
//            Opcode.POW_W -> TODO()
//            Opcode.POW_F -> TODO()
//            Opcode.NEG_B -> TODO()
//            Opcode.NEG_W -> TODO()
//            Opcode.NEG_F -> TODO()
//            Opcode.SHL_BYTE -> TODO()
//            Opcode.SHL_WORD -> TODO()
//            Opcode.SHL_MEM_BYTE -> TODO()
//            Opcode.SHL_MEM_WORD -> TODO()
//            Opcode.SHL_VAR_BYTE -> TODO()
//            Opcode.SHL_VAR_WORD -> TODO()
//            Opcode.SHR_BYTE -> TODO()
//            Opcode.SHR_WORD -> TODO()
//            Opcode.SHR_MEM_BYTE -> TODO()
//            Opcode.SHR_MEM_WORD -> TODO()
//            Opcode.SHR_VAR_BYTE -> TODO()
//            Opcode.SHR_VAR_WORD -> TODO()
//            Opcode.ROL_BYTE -> TODO()
//            Opcode.ROL_WORD -> TODO()
//            Opcode.ROL_MEM_BYTE -> TODO()
//            Opcode.ROL_MEM_WORD -> TODO()
//            Opcode.ROL_VAR_BYTE -> TODO()
//            Opcode.ROL_VAR_WORD -> TODO()
//            Opcode.ROR_BYTE -> TODO()
//            Opcode.ROR_WORD -> TODO()
//            Opcode.ROR_MEM_BYTE -> TODO()
//            Opcode.ROR_MEM_WORD -> TODO()
//            Opcode.ROR_VAR_BYTE -> TODO()
//            Opcode.ROR_VAR_WORD -> TODO()
//            Opcode.ROL2_BYTE -> TODO()
//            Opcode.ROL2_WORD -> TODO()
//            Opcode.ROL2_MEM_BYTE -> TODO()
//            Opcode.ROL2_MEM_WORD -> TODO()
//            Opcode.ROL2_VAR_BYTE -> TODO()
//            Opcode.ROL2_VAR_WORD -> TODO()
//            Opcode.ROR2_BYTE -> TODO()
//            Opcode.ROR2_WORD -> TODO()
//            Opcode.ROR2_MEM_BYTE -> TODO()
//            Opcode.ROR2_MEM_WORD -> TODO()
//            Opcode.ROR2_VAR_BYTE -> TODO()
//            Opcode.ROR2_VAR_WORD -> TODO()
//            Opcode.BITAND_BYTE -> TODO()
//            Opcode.BITAND_WORD -> TODO()
//            Opcode.BITOR_BYTE -> TODO()
//            Opcode.BITOR_WORD -> TODO()
//            Opcode.BITXOR_BYTE -> TODO()
//            Opcode.BITXOR_WORD -> TODO()
//            Opcode.INV_BYTE -> TODO()
//            Opcode.INV_WORD -> TODO()
//            Opcode.LSB -> TODO()
//            Opcode.MSB -> TODO()
//            Opcode.B2WORD -> TODO()
//            Opcode.UB2UWORD -> TODO()
//            Opcode.MSB2WORD -> TODO()
//            Opcode.B2FLOAT -> TODO()
//            Opcode.UB2FLOAT -> TODO()
//            Opcode.W2FLOAT -> TODO()
//            Opcode.UW2FLOAT -> TODO()
//            Opcode.AND_BYTE -> TODO()
//            Opcode.AND_WORD -> TODO()
//            Opcode.OR_BYTE -> TODO()
//            Opcode.OR_WORD -> TODO()
//            Opcode.XOR_BYTE -> TODO()
//            Opcode.XOR_WORD -> TODO()
//            Opcode.NOT_BYTE -> TODO()
//            Opcode.NOT_WORD -> TODO()
//            Opcode.LESS_B -> TODO()
//            Opcode.LESS_UB -> TODO()
//            Opcode.LESS_W -> TODO()
//            Opcode.LESS_UW -> TODO()
//            Opcode.LESS_F -> TODO()
//            Opcode.GREATER_B -> TODO()
//            Opcode.GREATER_UB -> TODO()
//            Opcode.GREATER_W -> TODO()
//            Opcode.GREATER_UW -> TODO()
//            Opcode.GREATER_F -> TODO()
//            Opcode.LESSEQ_B -> TODO()
//            Opcode.LESSEQ_UB -> TODO()
//            Opcode.LESSEQ_W -> TODO()
//            Opcode.LESSEQ_UW -> TODO()
//            Opcode.LESSEQ_F -> TODO()
//            Opcode.GREATEREQ_B -> TODO()
//            Opcode.GREATEREQ_UB -> TODO()
//            Opcode.GREATEREQ_W -> TODO()
//            Opcode.GREATEREQ_UW -> TODO()
//            Opcode.GREATEREQ_F -> TODO()
//            Opcode.EQUAL_BYTE -> TODO()
//            Opcode.EQUAL_WORD -> TODO()
//            Opcode.EQUAL_F -> TODO()
//            Opcode.NOTEQUAL_BYTE -> TODO()
//            Opcode.NOTEQUAL_WORD -> TODO()
//            Opcode.NOTEQUAL_F -> TODO()
//            Opcode.READ_INDEXED_VAR_BYTE -> TODO()
//            Opcode.READ_INDEXED_VAR_WORD -> TODO()
//            Opcode.READ_INDEXED_VAR_FLOAT -> TODO()
//            Opcode.WRITE_INDEXED_VAR_BYTE -> TODO()
//            Opcode.WRITE_INDEXED_VAR_WORD -> TODO()
//            Opcode.WRITE_INDEXED_VAR_FLOAT -> TODO()
//            Opcode.JUMP -> TODO()
//            Opcode.BCS -> TODO()
//            Opcode.BCC -> TODO()
//            Opcode.BZ -> TODO()
//            Opcode.BNZ -> TODO()
//            Opcode.BNEG -> TODO()
//            Opcode.BPOS -> TODO()
//            Opcode.CALL -> TODO()
//            Opcode.SYSCALL -> TODO()
//            Opcode.BREAKPOINT -> TODO()
        }
        return 0
    }
}
