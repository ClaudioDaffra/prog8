package prog8.compiler

import prog8.ast.IFunctionCall
import prog8.ast.Module
import prog8.ast.Program
import prog8.ast.base.*
import prog8.ast.expressions.*
import prog8.ast.processing.IAstVisitor
import prog8.ast.statements.*

class AstToSourceCode(val output: (text: String) -> Unit): IAstVisitor {
    var scopelevel = 0

    fun indent(s: String) = "    ".repeat(scopelevel) + s
    fun outputln(text: String) = output(text + "\n")
    fun outputlni(s: Any) = outputln(indent(s.toString()))
    fun outputi(s: Any) = output(indent(s.toString()))

    override fun visit(program: Program) {
        outputln("============= PROGRAM ${program.name} (FROM AST) ===============")
        super.visit(program)
        outputln("============= END PROGRAM ${program.name} (FROM AST) ===========")
    }

    override fun visit(module: Module) {
        if(!module.isLibraryModule) {
            outputln("; ----------- module: ${module.name} -----------")
            super.visit(module)
        }
        else outputln("; library module skipped: ${module.name}")
    }

    override fun visit(block: Block) {
        val addr = if(block.address!=null) block.address.toHex() else ""
        outputln("~ ${block.name} $addr {")
        scopelevel++
        for(stmt in block.statements) {
            outputi("")
            stmt.accept(this)
            output("\n")
        }
        scopelevel--
        outputln("}\n")
    }

    override fun visit(expr: PrefixExpression) {
        if(expr.operator.any { it.isLetter() })
            output(" ${expr.operator} ")
        else
            output(expr.operator)
        expr.expression.accept(this)
    }

    override fun visit(expr: BinaryExpression) {
        expr.left.accept(this)
        if(expr.operator.any { it.isLetter() })
            output(" ${expr.operator} ")
        else
            output(expr.operator)
        expr.right.accept(this)
    }

    override fun visit(directive: Directive) {
        output("${directive.directive} ")
        for(arg in directive.args) {
            when {
                arg.int!=null -> output(arg.int.toString())
                arg.name!=null -> output(arg.name)
                arg.str!=null -> output("\"${arg.str}\"")
            }
            if(arg!==directive.args.last())
                output(",")
        }
        output("\n")
    }

    fun datatypeString(dt: DataType): String {
        return when(dt) {
            in NumericDatatypes -> dt.toString().toLowerCase()
            in StringDatatypes -> dt.toString().toLowerCase()
            DataType.ARRAY_UB -> "ubyte["
            DataType.ARRAY_B -> "byte["
            DataType.ARRAY_UW -> "uword["
            DataType.ARRAY_W -> "word["
            DataType.ARRAY_F -> "float["
            else -> "?????"
        }
    }

    override fun visit(decl: VarDecl) {
        if(decl.autoGenerated) {
            // skip autogenerated vardecl
            return
        }

        when(decl.type) {
            VarDeclType.VAR -> {}
            VarDeclType.CONST -> output("const ")
            VarDeclType.MEMORY -> output("&")
        }
        output(datatypeString(decl.datatype))
        if(decl.arraysize!=null) {
            decl.arraysize!!.index.accept(this)
        }
        if(decl.isArray)
            output("]")

        if(decl.zeropage)
            output(" @zp")
        output(" ${decl.name} ")
        if(decl.value!=null) {
            output("= ")
            decl.value?.accept(this)
        }
    }

    override fun visit(subroutine: Subroutine) {
        output("\n")
        if(subroutine.isAsmSubroutine) {
            outputi("asmsub ${subroutine.name} (")
            for(param in subroutine.parameters.zip(subroutine.asmParameterRegisters)) {
                val reg =
                        when {
                            true==param.second.stack -> "stack"
                            param.second.registerOrPair!=null -> param.second.registerOrPair.toString()
                            param.second.statusflag!=null -> param.second.statusflag.toString()
                            else -> "?????"
                        }
                output("${datatypeString(param.first.type)} ${param.first.name} @$reg")
                if(param.first!==subroutine.parameters.last())
                    output(", ")
            }
        }
        else {
            outputi("sub ${subroutine.name} (")
            for(param in subroutine.parameters) {
                output("${datatypeString(param.type)} ${param.name}")
                if(param!==subroutine.parameters.last())
                    output(", ")
            }
        }
        output(") ")
        if(subroutine.asmClobbers.isNotEmpty()) {
            output("-> clobbers (")
            val regs = subroutine.asmClobbers.toList().sorted()
            for(r in regs) {
                output(r.toString())
                if(r!==regs.last())
                    output(",")
            }
            output(") ")
        }
        if(subroutine.returntypes.any()) {
            val rt = subroutine.returntypes.single()
            output("-> ${datatypeString(rt)} ")
        }
        if(subroutine.asmAddress!=null)
            outputln("= ${subroutine.asmAddress.toHex()}")
        else {
            outputln("{ ")
            scopelevel++
            subroutine.statements.forEach {
                outputi("")
                it.accept(this)
                output("\n")
            }
            scopelevel--
            outputi("}")
        }
    }

    override fun visit(functionCall: FunctionCall) {
        printout(functionCall as IFunctionCall)
    }

    override fun visit(functionCallStatement: FunctionCallStatement) {
        printout(functionCallStatement as IFunctionCall)
    }

    private fun printout(call: IFunctionCall) {
        call.target.accept(this)
        output("(")
        for(arg in call.arglist) {
            arg.accept(this)
            if(arg!==call.arglist.last())
                output(", ")
        }
        output(")")
    }

    override fun visit(identifier: IdentifierReference) {
        output(identifier.nameInSource.joinToString("."))
    }

    override fun visit(jump: Jump) {
        output("goto ")
        when {
            jump.address!=null -> output(jump.address.toHex())
            jump.generatedLabel!=null -> output(jump.generatedLabel)
            jump.identifier!=null -> jump.identifier.accept(this)
        }
    }

    override fun visit(ifStatement: IfStatement) {
        output("if ")
        ifStatement.condition.accept(this)
        output(" ")
        ifStatement.truepart.accept(this)
        if(ifStatement.elsepart.statements.isNotEmpty()) {
            output(" else ")
            ifStatement.elsepart.accept(this)
        }
    }

    override fun visit(branchStatement: BranchStatement) {
        output("if_${branchStatement.condition.toString().toLowerCase()} ")
        branchStatement.truepart.accept(this)
        if(branchStatement.elsepart.statements.isNotEmpty()) {
            output(" else ")
            branchStatement.elsepart.accept(this)
        }
    }

    override fun visit(range: RangeExpr) {
        range.from.accept(this)
        output(" to ")
        range.to.accept(this)
        output(" step ")
        range.step.accept(this)
        output(" ")
    }

    override fun visit(label: Label) {
        output("\n")
        output("${label.name}:")
    }

    override fun visit(literalValue: LiteralValue) {
        when {
            literalValue.isNumeric -> output(literalValue.asNumericValue.toString())
            literalValue.isString -> output("\"${literalValue.strvalue}\"")
            literalValue.isArray -> {
                output("[")
                for(v in literalValue.arrayvalue!!) {
                    v.accept(this)
                    if(v!==literalValue.arrayvalue.last())
                        output(", ")
                }
                output("]")
            }
        }
    }

    override fun visit(assignment: Assignment) {
        assignment.singleTarget!!.accept(this)
        if(assignment.aug_op!=null)
            output(" ${assignment.aug_op} ")
        else
            output(" = ")
        assignment.value.accept(this)
    }

    override fun visit(postIncrDecr: PostIncrDecr) {
        postIncrDecr.target.accept(this)
        output(postIncrDecr.operator)
    }

    override fun visit(contStmt: Continue) {
        output("continue")
    }

    override fun visit(breakStmt: Break) {
        output("break")
    }

    override fun visit(forLoop: ForLoop) {
        output("for ")
        if(forLoop.decltype!=null) {
            output(datatypeString(forLoop.decltype))
            if (forLoop.zeropage)
                output(" @zp ")
            else
                output(" ")
        }
        if(forLoop.loopRegister!=null)
            output(forLoop.loopRegister.toString())
        else
            forLoop.loopVar!!.accept(this)
        output(" in ")
        forLoop.iterable.accept(this)
        output(" ")
        forLoop.body.accept(this)
    }

    override fun visit(whileLoop: WhileLoop) {
        output("while ")
        whileLoop.condition.accept(this)
        output(" ")
        whileLoop.body.accept(this)
    }

    override fun visit(repeatLoop: RepeatLoop) {
        outputln("repeat ")
        repeatLoop.body.accept(this)
        output(" until ")
        repeatLoop.untilCondition.accept(this)
    }

    override fun visit(returnStmt: Return) {
        output("return ")
        for(v in returnStmt.values) {
            v.accept(this)
            if(v!==returnStmt.values.last())
                output(", ")
        }
    }

    override fun visit(arrayIndexedExpression: ArrayIndexedExpression) {
        arrayIndexedExpression.identifier.accept(this)
        output("[")
        arrayIndexedExpression.arrayspec.index.accept(this)
        output("]")
    }

    override fun visit(assignTarget: AssignTarget) {
        if(assignTarget.register!=null)
            output(assignTarget.register.toString())
        else {
            assignTarget.memoryAddress?.accept(this)
            assignTarget.identifier?.accept(this)
        }
        assignTarget.arrayindexed?.accept(this)
    }

    override fun visit(scope: AnonymousScope) {
        outputln("{")
        scopelevel++
        scope.statements.forEach {
            outputi("")
            it.accept(this)
            output("\n")
        }
        scopelevel--
        outputi("}")
    }

    override fun visit(typecast: TypecastExpression) {
        typecast.expression.accept(this)
        output(" as ${datatypeString(typecast.type)} ")
    }

    override fun visit(memread: DirectMemoryRead) {
        output("@(")
        memread.addressExpression.accept(this)
        output(")")
    }

    override fun visit(memwrite: DirectMemoryWrite) {
        output("@(")
        memwrite.addressExpression.accept(this)
        output(")")
    }

    override fun visit(addressOf: AddressOf) {
        output("&")
        addressOf.identifier.accept(this)
    }

    override fun visit(inlineAssembly: InlineAssembly) {
        outputlni("%asm {{")
        outputln(inlineAssembly.assembly)
        outputlni("}}")
    }

    override fun visit(registerExpr: RegisterExpr) {
        output(registerExpr.register.toString())
    }

    override fun visit(builtinFunctionStatementPlaceholder: BuiltinFunctionStatementPlaceholder) {
        output(builtinFunctionStatementPlaceholder.name)
    }

    override fun visit(nopStatement: NopStatement) {
        TODO("NOP???")
    }
}
