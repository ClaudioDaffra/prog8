; call tests

%output foobar


~ foo {



        var     .word   var1    = 99
        memory  .word   mem1    = $cff0

        var     .byte   varb1    = 99
        memory  .byte   memb1    = $cff0
        const   .word   constw   = $2355
        const   .byte   constb   = $23
        const   .float  constf   = 3.4556677
        const   .text   constt   = "derp"

        sub    sub1    () -> (X?)  = $ffdd
        sub    sub2    (A) -> (Y?)  = $eecc
        sub    sub3    (XY) -> (Y?)  = $ddaa
        sub    sub4    (string: XY, other  : A) -> (Y?)  = $dd22

bar2:

bar:    goto $c000
        goto var1               ; jumps to the address in var1
        goto mem1               ; jumps to the address in mem1
        goto &var1              ; strange, but jumps to the location in memory where var1 sits
        goto &mem1              ; strange, but jumps to the location in mempory where mem1 sits (points to)
        goto [var1]
        goto [$c000.word]
        goto [var1]
        goto [mem1]

        ; ----

        goto sub1
        ;goto sub2 (1  )         ; @todo error, must be return sub2(1)   -> optimized in 'tail call'
        return  sub2 (  )
        return  sub2 ()
        return  sub2 (1  )
        return  sub3 (3)
        return  sub3 (XY="hello")
        return  sub3 ("hello, there")
        return  sub4 (string="hello, there", other = 42)
        return  sub4 ("hello",  42)
        return  sub4 ("hello", other= 42)
        return  sub4 (string="hello", other = 42)
        return  bar  ()
	goto [AX]
	; goto [AX()]     % ; @todo error, must be return()
	goto [var1]
	goto   [mem1]                 ; comment
	return [AX]()
	return  [var1]   ()       ; comment
	return [mem1] ()
	goto $c000
	return $c000       ( )
	goto $c2
	return $c2()
	goto [$c2.word]
	return 33
	return [$c2.word]               ; @todo this as rvalue
	; [ $c2.word  (4) ]                 ;@ todo parse precedence
	return [$c2.word]  (4)
	return [$c2.word]  (4)
	return [$c2.word]  (4)
	return [$c2.word]  (4)
	; return [$c2dd.word] (  )         ;@ todo parse precedence
	goto [$c2dd.word]

        %asm {
                nop
                nop
                nop
                nop
        }

        sub1!()
        sub2!(11)
        sub3 !(3)
        sub3! (XY="hello")
        sub3! ("hello, there")
        sub4! ("hello",  42)
        sub4! ("hello",  other=42)
        sub4! (string="hello", other = 42)
        sub4! (string="hello, there", other = 42)

        sub3 (81)
        sub3 !(81)
        sub3 !A (81)
        sub3 !X (81)
        sub3 !Y (81)
        sub3 !XY (81)
        sub3 !AXY (81)

        bar!()
        bar !()
	[XY]! ()
	[XY] ! ()
	[var1]!()
	[mem1]!()
	[$c2.word]!()
	[$c2dd.word]!()
	$c000!()
	$c2!()

        %asm {
                nop
                nop
                nop
                nop
        }

        sub1()
        sub2(11)
        sub3 (3)
        sub3 (XY="hello")
        sub3 ("hello, there")
        sub4 ("hello",  42)
        sub4 ("hello", other=  42)
        sub4 (string="hello", other = 42)
        sub4 (string="hello, there", other = 42)
        bar ()
	[AX]()
	[var1] (  )
	[mem1]    ()
	A= [$c2.word(4)]
	;A= [$c2.word()   ] ; @todo Precedence?
	;A= [$c2dd.word() ] ; @todo Precedence?
	$c000()
	$c2()


        %asm {
                nop
                nop
                nop
                nop
        }

	constw()
	sub1()
	main.start()
}


~ main {

start:
        foo.bar()
	return

sub unused_sub ()->() {
        A=X
        X=Y
        Y=A
        return
}


}
