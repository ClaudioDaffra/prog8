; var definitions and immediate primitive data type tests

%output raw
%zp clobber


%import c64lib

~ ZP {
	; ZeroPage block definition:
	; base address is set to $04 (because $00 and $01 are used by the hardware, and $02/$03 are scratch)
	; everything here ends up in the zeropage, as long as there is space.
	; you can NOT put subroutines in here (yet).
}

~ ZP {
	var    zpvar1
	var    zpvar2
	memory zpmem1   = $f0
	const  zpconst  = 1.234
	var     .word   zpvarw1
	var     .word   zpvarw2
	var     .float  zpvarflt1  = 11.11
	var     .float  zpvarflt2  = 22.22
	var     .float  zpvarflt3

}

~ ZP {
	; will be merged with other ZP blocks!
	var zpvar1b      =   $88
}


~ foo {
        var    foovar1
	memory foomem1   = $f0f0
	const  fooconst  = 1.234
	return
}


~ main {
	; variables
	var			uninitbyte1
	var	.byte		uninitbyte2
	var     		initbyte1	=  $12
	var                     initbyte1b      = true
	var  .byte              initbyte2       = $12
	var  .byte              initbyte2b      = false
	var  .byte              initbyte3       = 99.876
	var                     initchar1       = '@'
	var  .byte              initchar2       = '@'
	var  .word              uninitword
	var  .word              initword1       = $1234
	var  .word              initword1b      = true
	var  .word              initword2       = false
	var  .word              initword3       = 9876.554321
	var  .word              initword5       = 20
	var  .float             uninitfloat
	var  .float             initfloat1      = 0
	var  .float             initfloat1b     = true
	var  .float             initfloat2      = -1.234e-14
	var  .float             initfloat3      = 9.87e+14
	var  .float             initfloat4      = 1.70141183e+38
	var  .float             initfloat5      = -1.70141183e+38
	var  .float             initfloat6      = 1.234

	var  .wordarray( 256 )   uninit_wordarray
	var  .wordarray(10)     init_wordarray          =  $1234
	var  .wordarray(10)     init_wordarrayb         =  true
	var  .array( 256)        uninit_bytearray
	var  .array(10 )        init_bytearray          =$12
	var  .array(10 )        init_bytearrayb         =true
	var  .array(10 )        init_bytearrayc         ='@'

	var  .text              text    = "hello-null"
	var  .ptext             ptext   = 'hello-pascal'
	var  .stext             stext   = 'screencodes-null'
	var  .pstext            pstext  = "screencodes-pascal"

	var  .matrix( 2, 128 ) uninitmatrix
	var  .matrix(10, 20)   initmatrix1      = $12
	var  .matrix(10, 20)   initmatrix1b     = true
	var  .matrix(10, 20)   initmatrix1c     = '@'
	var  .matrix(10, 20)   initmatrix1d     = 123.456

	; memory-mapped variables
	memory                          membyte1        = $cf01
	memory  .byte                   membyte2        = $c222
	memory  .word                   memword1        = $cf03
	memory  .float                  memfloat        = $cf04
	memory  .array(10 )             membytes        = $cf05
	memory  .wordarray( 10)         memwords        = $cf06
	memory  .matrix( 10, 20 )       memmatrix       = $cf07

	; constants   (= names for constant values, can never occur as lvalue)
	const                   cbyte1          = 1
	const                   cbyte1b         = false
	const  .byte            cbyte2          = 1
	const  .byte            cbyte3          = '@'
	const  .byte            cbyte4          = true
	const  .word            cword1          = false
	const  .word            cword2          = $1234
	const  .word            cword5          = 9876.5432
	const                   cfloat1         = 1.2345
	const  .float           cfloat2         = 2.3456
	const  .float           cfloat2b        = cfloat2*3.44
	const  .float           cfloat3         = true
	const  .text            ctext3   	= "constant-text"
	const  .ptext           ctext4   	= "constant-ptext"
	const  .stext           ctext5   	= "constant-stext"
	const  .pstext          ctext6   	= "constant-pstext"

        ; taking the address of various things:
	var .word        vmemaddr1              = &membyte1
	var .word        vmemaddr2              = &memword1
	var .word        vmemaddr3              = &memfloat
	var .word        vmemaddr4              = &membytes
	var .word        vmemaddr5              = &memwords
	var .word        vmemaddr6              = &memmatrix
	var .word        vmemaddr8              = 100*sin(cbyte1)
	var .word        vmemaddr9              = cword2+$5432
	var .word        vmemaddr10             = cfloat2b

	; taking the address of things from the ZP will work even when it is a var
	; because zp-vars get assigned a specific address (from a pool). Also, it's a byte.

	var .word        initword0a             = &ZP.zpmem1
	var              initbytea0             = &ZP.zpmem1


        ; (constant) expressions
	var     .word                expr_byte1b     =  -1-2-3-4-$22+$80+ZP.zpconst
	var     .byte           expr_fault2     =  1 + (8/3)+sin(33) + max(1,2,3)


sin:
        return

max:
        return


start:

; --- immediate primitive value assignments ----

	A = [$99]
	A = [$aabb]
	A = $99
        A = [cbyte3]
	A = 0
	A = '@'
	A = 1.2345
	A=X=Y= true
	A=XY= true
	A = false
	A = 255
	A = X
	A = [$99]
	A = [$c020.byte]
	A = [$c020]
        A = cbyte3
	A = membyte2
        A = uninitbyte1


	XY = 0
	XY = '@'
	XY = 1.2345
	XY = 456.66
	XY = 65535
	XY = true
	XY = false
	XY = text
	XY = cbyte3
	XY = [cbyte3]
	XY = [cword2]
	XY = uninitbyte1
	XY = "text-immediate"
	AY = "text-immediate"
	; AX = &"text-immediate"          ; equivalent to simply assigning the string directly
	; AX = & "text-immediate"         ; equivalent to simply assigning the string directly
	AX = ctext3
	AX = ""
	AX = XY
	AX = Y
	XY = membyte2
	XY = membyte2
	XY = memword1
	XY = sin
	; XY = &sin     ; @todo not yet implemented


	[$c000] = A
	[$c000] = 255
	[$c000] = '@'
	[$c000] = true
	[$c000] = false
	[$c000] = cbyte3
	[$c000] = uninitbyte1
	[$c000] = membyte2
	[$c000] = cbyte2
	[$c000] = [cword2]

	[$c000.word] = A
	[$c000.word] = AX
	[$c000.word] = cbyte3
	[$c000.word] = cword2
	[$c000.word] = ctext3
	[$c000.word] = 65535
	[$c000.word] = "text"
	[$c000.word] = ""
	[$c000.word] = uninitbyte1
	[$c000.word] = membyte2
	; [$c000.word] = &membyte2              ; @todo not yet implemented
	[$c000.word] = [cword2]
	[$c000.word] = memword1
	[$c000.float] = 65535
	[$c000.float] = 456.66
	[$c000.float] = 1.70141183e+38
	[$c000.float] = cbyte3
	[$c000.float] = cword2

	[$c001] = [$c002]
	[$c111.word] = [$c222]
        [$c112.word] = [$c223.byte]
	[$c222.word] = [$c333.word]
	[$c333.word] = sin
	; [$c333.word] = &sin           ; @todo not yet implemented


	SC = 0
	SC = 1
	SC = false
	SI = 1
	SI = 0
	SI = false

	uninitbyte1 = 99
	uninitbyte1 = 1.234
	uninitbyte1 = '@'
	initbyte1 = 99
	initbyte1 = 1.234
	initbyte1 = '@'
	initbyte1 = A
	initbyte1 = cbyte3
	uninitword = 99
	uninitword = 5.6778
	uninitword = "test"
	uninitword = '@'
	uninitword = A
	uninitword = XY
	uninitword = ctext3
	initword1 = cbyte3
	initword1 = cword2
	initfloat1 = 99
	initfloat1 = 9.8765
	initfloat1 = '@'
	initfloat1 = cbyte3
	initfloat1 = cword2
	uninitfloat = 99
	uninitfloat = 9.8765
	uninitfloat = '@'
	initword1 = sin
	; initword1 = &sin    ; @todo not yet implemented


        membyte1 = A
        membyte1 = cbyte3
        memword1 = A
        memword1 = AX
        memword1 = cbyte3
        memword1 = cword2
        memword1 = ctext3


        membyte1 = 22
        memword1 = 2233
        memfloat = 3.4567
	memword1 = sin
	; memword1 = &sin               ; @todo not yet implemented

        membyte1 = A
        memword1 = A
        memword1 = XY
        memfloat = cbyte3
        memfloat = cword2

        ; float assignments that require ROM functions from c64lib:
        memfloat = Y
        memfloat = XY
	uninitfloat = Y
	uninitfloat = XY
        initfloat2 = Y
        initfloat2 = XY
        initfloat2 = initbyte2
        initfloat2 = initword2
	initfloat1 = uninitfloat
	initfloat1 = initfloat2

	return
}

~ footer {
        XY = "text-immediate"   ; reuses existing
        AY = "text-immediate"   ; reuses existing
        AX = "another"
        AX = ""
        [$c000.word] = "another"               ; must reuse string
        [$c100.word] = "text-immediate"        ; must reuse string
        [$c200.word] = ""        ; must reuse string
        return
}
