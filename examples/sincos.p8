%import graphics
%import math
%import textio
%zeropage basicsafe

; Draw sine and cosine graphs. The sine and cosine functions are table lookups
; where the tables are generated by 64tass list functions.

; This uses the graphics library which works on multiple targets (C64, CX16)

main {
    const uword width = 320
    const ubyte height = 200

    sub start()  {
        graphics.enable_bitmap_mode()

        sincos255()
        sys.wait(60)

        graphics.clear_screen(1, 0)

        sincos180()
        sys.wait(60)

        graphics.clear_screen(1, 0)
        circles()
        sys.wait(60)

        graphics.disable_bitmap_mode()
        txt.print("done\n")
    }

    sub sincos255() {
        graphics.line(256,0,256,height-1)

        ubyte pixelyb
        ubyte pixelxb
        byte pixelys

        ; unsigned
        for pixelxb in 0 to 255 {
            pixelyb = math.cos8u(pixelxb) / 2
            graphics.plot(pixelxb, pixelyb+20)
            pixelyb = math.sin8u(pixelxb) / 2
            graphics.plot(pixelxb, pixelyb+20)
        }

        ; signed
        for pixelxb in 0 to 255 {
            pixelys = math.cos8(pixelxb) / 2
            graphics.plot(pixelxb, pixelys as ubyte + 90)
            pixelys = math.sin8(pixelxb) / 2
            graphics.plot(pixelxb, pixelys as ubyte + 90)
        }
    }

    sub sincos180() {
        graphics.line(180,0,180,height-1)

        ubyte pixelyb
        ubyte pixelxb
        byte pixelys

        ; signed
        for pixelxb in 0 to 179 {
            pixelyb = math.cosr8u(pixelxb) / 2
            graphics.plot(pixelxb, pixelyb+20)
            pixelyb = math.sinr8u(pixelxb) / 2
            graphics.plot(pixelxb, pixelyb+20)
        }

        ; unsigned
        for pixelxb in 0 to 179 {
            pixelys = math.cosr8(pixelxb) / 2
            graphics.plot(pixelxb, pixelys as ubyte + 90)
            pixelys = math.sinr8(pixelxb) / 2
            graphics.plot(pixelxb, pixelys as ubyte + 90)
        }
    }

    sub circles() {
        ubyte pixelyb
        uword pixelxw
        ubyte r

        ; circle with "degrees" from 0 to 255
        for r in 0 to 255 {
            pixelxw = (math.sin8(r)/2 as word) + 80 as uword
            pixelyb = (math.cos8(r)/2 as uword + height/2) as ubyte
            graphics.plot(pixelxw, pixelyb)
        }

        for r in 0 to 255 {
            pixelxw = math.sin8u(r)/2
            pixelyb = math.cos8u(r)/2
            graphics.plot(pixelxw + 16, pixelyb+50)
        }

        ; circle with half-degrees from 0 to 179 (=full degrees 0..358 with steps of 2 degrees)
        for r in 0 to 179 {
            pixelxw = (math.sinr8(r) as word /2 + 220) as uword
            pixelyb = (math.cosr8(r)/2 + height/2) as ubyte
            graphics.plot(pixelxw, pixelyb)
        }

        for r in 0 to 179 {
            pixelxw = math.sinr8u(r)/2
            pixelyb = math.cosr8u(r)/2
            graphics.plot(pixelxw + 156, pixelyb+50)
        }
    }
}
