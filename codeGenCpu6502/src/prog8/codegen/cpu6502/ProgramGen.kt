package prog8.codegen.cpu6502

import com.github.michaelbull.result.fold
import prog8.ast.IFunctionCall
import prog8.ast.Program
import prog8.ast.antlr.escape
import prog8.ast.base.*
import prog8.ast.expressions.*
import prog8.ast.statements.*
import prog8.ast.toHex
import prog8.codegen.cpu6502.assignment.AsmAssignTarget
import prog8.codegen.cpu6502.assignment.TargetStorageKind
import prog8.compilerinterface.*
import java.time.LocalDate
import java.time.LocalDateTime
import kotlin.math.absoluteValue


internal class ProgramGen(
    val program: Program,
    val variables: IVariablesAndConsts,
    val options: CompilationOptions,
    val errors: IErrorReporter,
    private val functioncallAsmGen: FunctionCallAsmGen,
    private val asmgen: AsmGen,
    private val allocator: VariableAllocator,
    private val zeropage: Zeropage
) {
    private val compTarget = options.compTarget
    private val callGraph = CallGraph(program)
    private val blockVariableInitializers = program.allBlocks.associateWith { it.statements.filterIsInstance<Assignment>() }

    internal fun generate() {
        val allInitializers = blockVariableInitializers.asSequence().flatMap { it.value }
        require(allInitializers.all { it.origin==AssignmentOrigin.VARINIT }) {"all block-level assignments must be a variable initializer"}

        header()
        val allBlocks = program.allBlocks
        if(allBlocks.first().name != "main")
            throw AssemblyError("first block should be 'main'")

        allocator.allocateZeropageVariables(options)
        if(errors.noErrors())  {
            program.allBlocks.forEach { block2asm(it) }
            memorySlabs()
            footer()
        }
    }

    private fun header() {
        val ourName = this.javaClass.name
        val cpu = when(compTarget.machine.cpu) {
            CpuType.CPU6502 -> "6502"
            CpuType.CPU65c02 -> "w65c02"
            else -> "unsupported"
        }

        asmgen.out("; $cpu assembly code for '${program.name}'")
        asmgen.out("; generated by $ourName on ${LocalDateTime.now().withNano(0)}")
        asmgen.out("; assembler syntax is for the 64tasm cross-assembler")
        asmgen.out("; output options: output=${options.output} launcher=${options.launcher} zp=${options.zeropage}")
        asmgen.out("\n.cpu  '$cpu'\n.enc  'none'\n")

        program.actualLoadAddress = program.definedLoadAddress
        if (program.actualLoadAddress == 0u)   // fix load address
            program.actualLoadAddress = if (options.launcher == LauncherType.BASIC)
                compTarget.machine.BASIC_LOAD_ADDRESS else compTarget.machine.RAW_LOAD_ADDRESS

        // the global prog8 variables needed
        val zp = zeropage
        asmgen.out("P8ZP_SCRATCH_B1 = ${zp.SCRATCH_B1}")
        asmgen.out("P8ZP_SCRATCH_REG = ${zp.SCRATCH_REG}")
        asmgen.out("P8ZP_SCRATCH_W1 = ${zp.SCRATCH_W1}    ; word")
        asmgen.out("P8ZP_SCRATCH_W2 = ${zp.SCRATCH_W2}    ; word")
        asmgen.out("P8ESTACK_LO = ${compTarget.machine.ESTACK_LO.toHex()}")
        asmgen.out("P8ESTACK_HI = ${compTarget.machine.ESTACK_HI.toHex()}")

        when {
            options.launcher == LauncherType.BASIC -> {
                if (program.actualLoadAddress != options.compTarget.machine.BASIC_LOAD_ADDRESS)
                    throw AssemblyError("BASIC output must have correct load address")
                asmgen.out("; ---- basic program with sys call ----")
                asmgen.out("* = ${program.actualLoadAddress.toHex()}")
                val year = LocalDate.now().year
                asmgen.out("  .word  (+), $year")
                asmgen.out("  .null  $9e, format(' %d ', prog8_entrypoint), $3a, $8f, ' prog8'")
                asmgen.out("+\t.word  0")
                asmgen.out("prog8_entrypoint\t; assembly code starts here\n")
                if(!options.noSysInit)
                    asmgen.out("  jsr  ${compTarget.name}.init_system")
                asmgen.out("  jsr  ${compTarget.name}.init_system_phase2")
            }
            options.output == OutputType.PRG -> {
                asmgen.out("; ---- program without basic sys call ----")
                asmgen.out("* = ${program.actualLoadAddress.toHex()}\n")
                if(!options.noSysInit)
                    asmgen.out("  jsr  ${compTarget.name}.init_system")
                asmgen.out("  jsr  ${compTarget.name}.init_system_phase2")
            }
            options.output == OutputType.RAW -> {
                asmgen.out("; ---- raw assembler program ----")
                asmgen.out("* = ${program.actualLoadAddress.toHex()}\n")
            }
        }

        if(options.zeropage !in arrayOf(ZeropageType.BASICSAFE, ZeropageType.DONTUSE)) {
            asmgen.out("""
                ; zeropage is clobbered so we need to reset the machine at exit
                lda  #>sys.reset_system
                pha
                lda  #<sys.reset_system
                pha""")
        }

        // make sure that on the cx16 and c64, basic rom is banked in again when we exit the program
        when(compTarget.name) {
            "cx16" -> {
                if(options.floats)
                    asmgen.out("  lda  #4 |  sta  $01")    // to use floats, make sure Basic rom is banked in
                asmgen.out("  jsr  main.start |  lda  #4 |  sta  $01 |  rts")
            }
            "c64" -> asmgen.out("  jsr  main.start |  lda  #31 |  sta  $01 |  rts")
            else -> asmgen.jmp("main.start")
        }
    }

    private fun memorySlabs() {
        asmgen.out("; memory slabs")
        asmgen.out("prog8_slabs\t.block")
        for((name, info) in allocator.memorySlabs) {
            if(info.second>1u)
                asmgen.out("\t.align  ${info.second.toHex()}")
            asmgen.out("$name\t.fill  ${info.first}")
        }
        asmgen.out("\t.bend")
    }

    private fun footer() {
        // the global list of all floating point constants for the whole program
        asmgen.out("; global float constants")
        for (flt in allocator.globalFloatConsts) {
            val floatFill = compTarget.machine.getFloat(flt.key).makeFloatFillAsm()
            val floatvalue = flt.key
            asmgen.out("${flt.value}\t.byte  $floatFill  ; float $floatvalue")
        }

        // program end
        asmgen.out("prog8_program_end\t; end of program label for progend()")
    }

    private fun block2asm(block: Block) {
        asmgen.out("\n\n; ---- block: '${block.name}' ----")
        if(block.address!=null)
            asmgen.out("* = ${block.address!!.toHex()}")
        else {
            if("align_word" in block.options())
                asmgen.out("\t.align 2")
            else if("align_page" in block.options())
                asmgen.out("\t.align $100")
        }

        asmgen.out("${block.name}\t" + (if("force_output" in block.options()) ".block\n" else ".proc\n"))

        asmgen.outputSourceLine(block)

        val vardecls = block.statements.filterIsInstance<VarDecl>()
        zeropagevars2asm(vardecls, block)
        memdefs2asmVars(vardecls, block)
        memdefs2asmAsmsubs(block.statements.filterIsInstance<Subroutine>(), block)
        vardecls2asm(vardecls, block)

        vardecls.forEach {
            if(it.type== VarDeclType.VAR && it.datatype in NumericDatatypes)
                it.value=null  // make sure every var has no init value any longer (could be set due to 'noreinit' option) because initialization is done via explicit assignment
        }

        asmgen.out("\n; subroutines in this block")

        // First translate regular statements, and then put the subroutines at the end.
        // (regular statements = everything except the initialization assignments;
        // these will be part of the prog8_init_vars init routine generated below)
        val initializers = blockVariableInitializers.getValue(block)
        val statements = block.statements.filterNot { it in initializers }
        val (subroutine, stmts) = statements.partition { it is Subroutine }
        stmts.forEach { asmgen.translate(it) }
        subroutine.forEach { asmgen.translate(it) }

        if(!options.dontReinitGlobals) {
            // generate subroutine to initialize block-level (global) variables
            if (initializers.isNotEmpty()) {
                asmgen.out("prog8_init_vars\t.proc\n")
                initializers.forEach { assign -> asmgen.translate(assign) }
                asmgen.out("  rts\n  .pend")
            }
        }

        asmgen.out(if("force_output" in block.options()) "\n\t.bend\n" else "\n\t.pend\n")
    }

    internal fun translateSubroutine(sub: Subroutine) {
        var onlyVariables = false

        if(sub.inline) {
            if(options.optimize) {
                if(sub.isAsmSubroutine || callGraph.unused(sub))
                    return

                // from an inlined subroutine only the local variables are generated,
                // all other code statements are omitted in the subroutine itself
                // (they've been inlined at the call site, remember?)
                onlyVariables = true
            }
        }

        asmgen.out("")

        if(sub.isAsmSubroutine) {
            if(sub.asmAddress!=null)
                return  // already done at the memvars section

            // asmsub with most likely just an inline asm in it
            asmgen.out("${sub.name}\t.proc")
            sub.statements.forEach { asmgen.translate(it) }
            asmgen.out("  .pend\n")
        } else {
            // regular subroutine
            asmgen.out("${sub.name}\t.proc")
            val vardecls = sub.statements.filterIsInstance<VarDecl>()
            zeropagevars2asm(vardecls, null)
            memdefs2asmVars(vardecls, null)
            memdefs2asmAsmsubs(sub.statements.filterIsInstance<Subroutine>(), null)

            // the main.start subroutine is the program's entrypoint and should perform some initialization logic
            if(sub.name=="start" && sub.definingBlock.name=="main")
                entrypointInitialization()

            if(functioncallAsmGen.optimizeIntArgsViaRegisters(sub)) {
                asmgen.out("; simple int arg(s) passed via register(s)")
                if(sub.parameters.size==1) {
                    val dt = sub.parameters[0].type
                    val target = AsmAssignTarget(TargetStorageKind.VARIABLE, program, asmgen, dt, sub, variableAsmName = sub.parameters[0].name)
                    if(dt in ByteDatatypes)
                        asmgen.assignRegister(RegisterOrPair.A, target)
                    else
                        asmgen.assignRegister(RegisterOrPair.AY, target)
                } else {
                    require(sub.parameters.size==2)
                    // 2 simple byte args, first in A, second in Y
                    val target1 = AsmAssignTarget(TargetStorageKind.VARIABLE, program, asmgen, sub.parameters[0].type, sub, variableAsmName = sub.parameters[0].name)
                    val target2 = AsmAssignTarget(TargetStorageKind.VARIABLE, program, asmgen, sub.parameters[1].type, sub, variableAsmName = sub.parameters[1].name)
                    asmgen.assignRegister(RegisterOrPair.A, target1)
                    asmgen.assignRegister(RegisterOrPair.Y, target2)
                }
            }

            if(!onlyVariables) {
                asmgen.out("; statements")
                sub.statements.forEach { asmgen.translate(it) }
            }

            asmgen.out("; variables")
            val asmGenInfo = allocator.subroutineExtra(sub)
            for((dt, name, addr) in asmGenInfo.extraVars) {
                if(addr!=null)
                    asmgen.out("$name = $addr")
                else when(dt) {
                    DataType.UBYTE -> asmgen.out("$name    .byte  0")
                    DataType.UWORD -> asmgen.out("$name    .word  0")
                    else -> throw AssemblyError("weird dt")
                }
            }
            if(asmGenInfo.usedRegsaveA)      // will probably never occur
                asmgen.out("prog8_regsaveA     .byte  0")
            if(asmGenInfo.usedRegsaveX)
                asmgen.out("prog8_regsaveX     .byte  0")
            if(asmGenInfo.usedRegsaveY)
                asmgen.out("prog8_regsaveY     .byte  0")
            if(asmGenInfo.usedFloatEvalResultVar1)
                asmgen.out("$subroutineFloatEvalResultVar1    .byte  0,0,0,0,0")
            if(asmGenInfo.usedFloatEvalResultVar2)
                asmgen.out("$subroutineFloatEvalResultVar2    .byte  0,0,0,0,0")
            vardecls2asm(vardecls, null)
            asmgen.out("  .pend\n")
        }
    }

    private fun entrypointInitialization() {
        asmgen.out("; program startup initialization")
        asmgen.out("  cld")
        if(!options.dontReinitGlobals) {
            blockVariableInitializers.forEach {
                if (it.value.isNotEmpty())
                    asmgen.out("  jsr  ${it.key.name}.prog8_init_vars")
            }
        }

        val zp = zeropage
        // string and array variables in zeropage that have initializer value, should be initialized
        val stringVarsWithInitInZp = zp.variables.filter { it.value.dt==DataType.STR && it.value.initialStringValue!=null }
        val arrayVarsWithInitInZp = zp.variables.filter { it.value.dt in ArrayDatatypes && it.value.initialArrayValue!=null }
        if(stringVarsWithInitInZp.isNotEmpty() || arrayVarsWithInitInZp.isNotEmpty()) {
            asmgen.out("; zp str and array initializations")
            stringVarsWithInitInZp.forEach {
                val name = asmgen.asmVariableName(it.key)
                asmgen.out("""
                    lda  #<${name}
                    ldy  #>${name}
                    sta  P8ZP_SCRATCH_W1
                    sty  P8ZP_SCRATCH_W1+1
                    lda  #<${name}_init_value
                    ldy  #>${name}_init_value
                    jsr  prog8_lib.strcpy""")
            }
            arrayVarsWithInitInZp.forEach {
                val size = it.value.size
                val name = asmgen.asmVariableName(it.key)
                asmgen.out("""
                    lda  #<${name}_init_value
                    ldy  #>${name}_init_value
                    sta  cx16.r0L
                    sty  cx16.r0H
                    lda  #<${name}
                    ldy  #>${name}
                    sta  cx16.r1L
                    sty  cx16.r1H
                    lda  #<$size
                    ldy  #>$size
                    jsr  sys.memcopy""")
            }
            asmgen.out("  jmp  +")
        }

        stringVarsWithInitInZp.forEach {
            val varname = asmgen.asmVariableName(it.key)+"_init_value"
            val sv = it.value.initialStringValue!!
            outputStringvar(varname, it.value.dt, sv.encoding, sv.value)
        }

        arrayVarsWithInitInZp.forEach {
            val varname = asmgen.asmVariableName(it.key)+"_init_value"
            val av = it.value.initialArrayValue!!
            arrayVardecl2asm(varname, it.value.dt, av, null)
        }

        asmgen.out("""+       tsx
                    stx  prog8_lib.orig_stackpointer    ; required for sys.exit()                    
                    ldx  #255       ; init estack ptr
                    clv
                    clc""")
    }

    private fun zeropagevars2asm(vardecls: List<VarDecl>, inBlock: Block?) {
        val zp = zeropage
        asmgen.out("; vars allocated on zeropage")
        val variables = vardecls.filter { it.type==VarDeclType.VAR }
        val blockname = inBlock?.name
        for(variable in variables) {
            if(blockname=="prog8_lib" && variable.name.startsWith("P8ZP_SCRATCH_"))
                continue       // the "hooks" to the temp vars are not generated as new variables
            val scopedName = variable.scopedName
            val zpAlloc = zp.variables[scopedName]
            if (zpAlloc == null) {
                // TODO NO LONGER ALLOCATE HERE, IT'S ALL BEEN DONE IN THE VARIABLEALLOCATOR ALREADY
                // This var is not on the ZP yet. Attempt to move it there if it's an integer type
                if(variable.zeropage != ZeropageWish.NOT_IN_ZEROPAGE &&
                    variable.datatype in IntegerDatatypes
                    && options.zeropage != ZeropageType.DONTUSE) {
                    val result = zp.allocate(scopedName, variable.datatype, null, null, null, errors)
                    errors.report()
                    result.fold(
                        success = { (address, _) -> asmgen.out("${variable.name} = $address\t; zp ${variable.datatype}") },
                        failure = { /* leave it as it is, not on zeropage. */ }
                    )
                }
            } else {
                // Var has been placed in ZP, just output the address
                val lenspec = when(zpAlloc.dt) {
                    DataType.FLOAT,
                    DataType.STR,
                    in ArrayDatatypes -> " ${zpAlloc.size} bytes"
                    else -> ""
                }
                asmgen.out("${variable.name} = ${zpAlloc.address}\t; zp ${variable.datatype} $lenspec")
            }
        }
    }

    private fun vardecl2asm(decl: VarDecl, nameOverride: String?=null) {
        val name = nameOverride ?: decl.name
        val value = decl.value
        val staticValue: Number =
            if(value!=null) {
                if(value is NumericLiteralValue) {
                    if(value.type== DataType.FLOAT)
                        value.number
                    else
                        value.number.toInt()
                } else {
                    if(decl.datatype in NumericDatatypes)
                        throw AssemblyError("can only deal with constant numeric values for global vars $value at ${decl.position}")
                    else 0
                }
            } else 0

        when (decl.datatype) {
            DataType.UBYTE -> asmgen.out("$name\t.byte  ${staticValue.toHex()}")
            DataType.BYTE -> asmgen.out("$name\t.char  $staticValue")
            DataType.UWORD -> asmgen.out("$name\t.word  ${staticValue.toHex()}")
            DataType.WORD -> asmgen.out("$name\t.sint  $staticValue")
            DataType.FLOAT -> {
                if(staticValue==0) {
                    asmgen.out("$name\t.byte  0,0,0,0,0  ; float")
                } else {
                    val floatFill = compTarget.machine.getFloat(staticValue).makeFloatFillAsm()
                    asmgen.out("$name\t.byte  $floatFill  ; float $staticValue")
                }
            }
            DataType.STR -> {
                throw AssemblyError("all string vars should have been interned into prog")
            }
            in ArrayDatatypes -> arrayVardecl2asm(name, decl.datatype, decl.value as? ArrayLiteralValue, decl.arraysize?.constIndex())
            else -> {
                throw AssemblyError("weird dt")
            }
        }
    }

    private fun arrayVardecl2asm(varname: String, dt: DataType, value: ArrayLiteralValue?, orNumberOfZeros: Int?) {
        when(dt) {
            DataType.ARRAY_UB -> {
                val data = makeArrayFillDataUnsigned(dt, value, orNumberOfZeros)
                if (data.size <= 16)
                    asmgen.out("$varname\t.byte  ${data.joinToString()}")
                else {
                    asmgen.out(varname)
                    for (chunk in data.chunked(16))
                        asmgen.out("  .byte  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_B -> {
                val data = makeArrayFillDataSigned(dt, value, orNumberOfZeros)
                if (data.size <= 16)
                    asmgen.out("$varname\t.char  ${data.joinToString()}")
                else {
                    asmgen.out(varname)
                    for (chunk in data.chunked(16))
                        asmgen.out("  .char  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_UW -> {
                val data = makeArrayFillDataUnsigned(dt, value, orNumberOfZeros)
                if (data.size <= 16)
                    asmgen.out("$varname\t.word  ${data.joinToString()}")
                else {
                    asmgen.out(varname)
                    for (chunk in data.chunked(16))
                        asmgen.out("  .word  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_W -> {
                val data = makeArrayFillDataSigned(dt, value, orNumberOfZeros)
                if (data.size <= 16)
                    asmgen.out("$varname\t.sint  ${data.joinToString()}")
                else {
                    asmgen.out(varname)
                    for (chunk in data.chunked(16))
                        asmgen.out("  .sint  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_F -> {
                val array = value?.value ?:
                                Array(orNumberOfZeros!!) { defaultZero(ArrayToElementTypes.getValue(dt), Position.DUMMY) }
                val floatFills = array.map {
                    val number = (it as NumericLiteralValue).number
                    compTarget.machine.getFloat(number).makeFloatFillAsm()
                }
                asmgen.out(varname)
                for (f in array.zip(floatFills))
                    asmgen.out("  .byte  ${f.second}  ; float ${f.first}")
            }
            else -> throw AssemblyError("require array dt")
        }
    }

    private fun memdefs2asmVars(vardecls: List<VarDecl>, inBlock: Block?) {
        val blockname = inBlock?.name
        asmgen.out("\n; memdefs and kernal subroutines")
        vardecls
            .filter { it.type==VarDeclType.MEMORY || it.type==VarDeclType.CONST }
            .forEach { mv ->
                if(blockname!="prog8_lib" || !mv.name.startsWith("P8ZP_SCRATCH_"))      // the "hooks" to the temp vars are not generated as new variables
                    if(mv.value is NumericLiteralValue)
                        asmgen.out("  ${mv.name} = ${(mv.value as NumericLiteralValue).number.toHex()}")
                    else
                        asmgen.out("  ${mv.name} = ${asmgen.asmVariableName((mv.value as AddressOf).identifier)}")
            }
    }

    private fun memdefs2asmAsmsubs(subroutines: List<Subroutine>, inBlock: Block?) {
        subroutines
            .filter { it.isAsmSubroutine }
            .forEach { sub->
                val addr = sub.asmAddress
                if(addr!=null) {
                    if(sub.statements.isNotEmpty())
                        throw AssemblyError("kernal subroutine cannot have statements")
                    asmgen.out("  ${sub.name} = ${addr.toHex()}")
                }
            }
    }

    private fun vardecls2asm(vardecls: List<VarDecl>, inBlock: Block?) {
        asmgen.out("\n; non-zeropage variables")
        val vars = vardecls.filter {
                it.type==VarDeclType.VAR
                        && it.zeropage!= ZeropageWish.REQUIRE_ZEROPAGE
                        && it.scopedName !in zeropage.variables
            }

        vars.filter { it.datatype == DataType.STR && shouldActuallyOutputStringVar(it) }
            .forEach { outputStringvar(it) }

        // non-string variables
        val blockname = inBlock?.name

        vars.filter{ it.datatype != DataType.STR }.sortedBy { it.datatype }.forEach {
            require(it.zeropage!= ZeropageWish.REQUIRE_ZEROPAGE)
            if(!asmgen.isZpVar(it.scopedName)) {
                if(blockname!="prog8_lib" || !it.name.startsWith("P8ZP_SCRATCH_"))      // the "hooks" to the temp vars are not generated as new variables
                    vardecl2asm(it)
            }
        }
    }

    private fun shouldActuallyOutputStringVar(strvar: VarDecl): Boolean {
        if(strvar.sharedWithAsm)
            return true
        val uses = callGraph.usages(strvar)
        val onlyInMemoryFuncs = uses.all {
            val builtinfunc = (it.parent as? IFunctionCall)?.target?.targetStatement(program) as? BuiltinFunctionPlaceholder
            builtinfunc?.name=="memory"
        }
        return !onlyInMemoryFuncs
    }

    private fun outputStringvar(strdecl: VarDecl, nameOverride: String?=null) {
        val varname = nameOverride ?: strdecl.name
        val sv = strdecl.value as StringLiteralValue
        outputStringvar(varname, strdecl.datatype, sv.encoding, sv.value)
    }

    private fun outputStringvar(varname: String, dt: DataType, encoding: Encoding, value: String) {
        asmgen.out("$varname\t; $dt $encoding:\"${escape(value).replace("\u0000", "<NULL>")}\"")
        val bytes = compTarget.encodeString(value, encoding).plus(0.toUByte())
        val outputBytes = bytes.map { "$" + it.toString(16).padStart(2, '0') }
        for (chunk in outputBytes.chunked(16))
            asmgen.out("  .byte  " + chunk.joinToString())
    }

    private fun makeArrayFillDataUnsigned(dt: DataType, value: ArrayLiteralValue?, orNumberOfZeros: Int?): List<String> {
        val array = value?.value ?:
                        Array(orNumberOfZeros!!) { defaultZero(ArrayToElementTypes.getValue(dt), Position.DUMMY) }
        return when (dt) {
            DataType.ARRAY_UB ->
                // byte array can never contain pointer-to types, so treat values as all integers
                array.map {
                    val number = (it as NumericLiteralValue).number.toInt()
                    "$"+number.toString(16).padStart(2, '0')
                }
            DataType.ARRAY_UW -> array.map {
                when (it) {
                    is NumericLiteralValue -> {
                        "$" + it.number.toInt().toString(16).padStart(4, '0')
                    }
                    is AddressOf -> {
                        asmgen.asmSymbolName(it.identifier)
                    }
                    is IdentifierReference -> {
                        asmgen.asmSymbolName(it)
                    }
                    else -> throw AssemblyError("weird array elt dt")
                }
            }
            else -> throw AssemblyError("invalid dt")
        }
    }

    private fun makeArrayFillDataSigned(dt: DataType, value: ArrayLiteralValue?, orNumberOfZeros: Int?): List<String> {
        val array = value?.value ?:
                        Array(orNumberOfZeros!!) { defaultZero(ArrayToElementTypes.getValue(dt), Position.DUMMY) }
        return when (dt) {
            DataType.ARRAY_UB ->
                // byte array can never contain pointer-to types, so treat values as all integers
                array.map {
                    val number = (it as NumericLiteralValue).number.toInt()
                    "$"+number.toString(16).padStart(2, '0')
                }
            DataType.ARRAY_B ->
                // byte array can never contain pointer-to types, so treat values as all integers
                array.map {
                    val number = (it as NumericLiteralValue).number.toInt()
                    val hexnum = number.absoluteValue.toString(16).padStart(2, '0')
                    if(number>=0)
                        "$$hexnum"
                    else
                        "-$$hexnum"
                }
            DataType.ARRAY_UW -> array.map {
                val number = (it as NumericLiteralValue).number.toInt()
                "$" + number.toString(16).padStart(4, '0')
            }
            DataType.ARRAY_W -> array.map {
                val number = (it as NumericLiteralValue).number.toInt()
                val hexnum = number.absoluteValue.toString(16).padStart(4, '0')
                if(number>=0)
                    "$$hexnum"
                else
                    "-$$hexnum"
            }
            else -> throw AssemblyError("invalid dt")
        }
    }

}