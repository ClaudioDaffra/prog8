package prog8.codegen.cpu6502

import prog8.ast.INameScope
import prog8.ast.Program
import prog8.ast.antlr.escape
import prog8.ast.base.*
import prog8.ast.expressions.*
import prog8.ast.statements.*
import prog8.ast.toHex
import prog8.codegen.cpu6502.assignment.AsmAssignTarget
import prog8.codegen.cpu6502.assignment.TargetStorageKind
import prog8.compilerinterface.*
import java.time.LocalDate
import java.time.LocalDateTime
import kotlin.math.absoluteValue

/**
 * Generates the main parts of the program:
 *  - entry/exit code
 *  - initialization routines
 *  - blocks
 *  - subroutines
 *  - all variables (note: VarDecl ast nodes are *NOT* used anymore for this! now uses IVariablesAndConsts data tables!)
 */
internal class ProgramAndVarsGen(
    val program: Program,
    val variables: IVariablesAndConsts,
    val options: CompilationOptions,
    val errors: IErrorReporter,
    private val functioncallAsmGen: FunctionCallAsmGen,
    private val asmgen: AsmGen,
    private val allocator: VariableAllocator,
    private val zeropage: Zeropage
) {
    private val compTarget = options.compTarget
    private val callGraph = CallGraph(program, true)
    private val blockVariableInitializers = program.allBlocks.associateWith { it.statements.filterIsInstance<Assignment>() }

    internal fun generate() {
        val allInitializers = blockVariableInitializers.asSequence().flatMap { it.value }
        require(allInitializers.all { it.origin==AssignmentOrigin.VARINIT }) {"all block-level assignments must be a variable initializer"}

        allocator.allocateZeropageVariables()

        header()
        val allBlocks = program.allBlocks
        if(allBlocks.first().name != "main")
            throw AssemblyError("first block should be 'main'")

        if(errors.noErrors())  {
            program.allBlocks.forEach { block2asm(it) }
            memorySlabs()
            footer()
        }
    }

    private fun header() {
        val ourName = this.javaClass.name
        val cpu = when(compTarget.machine.cpu) {
            CpuType.CPU6502 -> "6502"
            CpuType.CPU65c02 -> "w65c02"
            else -> "unsupported"
        }

        asmgen.out("; $cpu assembly code for '${program.name}'")
        asmgen.out("; generated by $ourName on ${LocalDateTime.now().withNano(0)}")
        asmgen.out("; assembler syntax is for the 64tasm cross-assembler")
        asmgen.out("; output options: output=${options.output} launcher=${options.launcher} zp=${options.zeropage}")
        asmgen.out("")
        asmgen.out(".cpu  '$cpu'\n.enc  'none'\n")

        program.actualLoadAddress = program.definedLoadAddress
        if (program.actualLoadAddress == 0u) {
            when(options.output) {
                OutputType.RAW -> {
                    errors.err("load address must be specified with %address when using raw output type", program.toplevelModule.position)
                    return
                }
                OutputType.PRG -> {
                    when(options.launcher) {
                        CbmPrgLauncherType.BASIC -> {
                            program.actualLoadAddress = compTarget.machine.PROGRAM_LOAD_ADDRESS
                        }
                        CbmPrgLauncherType.NONE -> {
                            errors.err("load address must be specified with %address when not using basic launcher", program.toplevelModule.position)
                            return
                        }
                    }
                }
                OutputType.XEX -> {
                    if(options.launcher!=CbmPrgLauncherType.NONE)
                        throw AssemblyError("atari xex output can't contain BASIC launcher")
                    program.actualLoadAddress = compTarget.machine.PROGRAM_LOAD_ADDRESS
                }
            }
        }

        // the global prog8 variables needed
        val zp = zeropage
        asmgen.out("P8ZP_SCRATCH_B1 = ${zp.SCRATCH_B1}")
        asmgen.out("P8ZP_SCRATCH_REG = ${zp.SCRATCH_REG}")
        asmgen.out("P8ZP_SCRATCH_W1 = ${zp.SCRATCH_W1}    ; word")
        asmgen.out("P8ZP_SCRATCH_W2 = ${zp.SCRATCH_W2}    ; word")
        asmgen.out("P8ESTACK_LO = ${compTarget.machine.ESTACK_LO.toHex()}")
        asmgen.out("P8ESTACK_HI = ${compTarget.machine.ESTACK_HI.toHex()}")

        when(options.output) {
            OutputType.RAW -> {
                asmgen.out("; ---- raw assembler program ----")
                asmgen.out("* = ${program.actualLoadAddress.toHex()}\n")
            }
            OutputType.PRG -> {
                when(options.launcher) {
                    CbmPrgLauncherType.BASIC -> {
                        if (program.actualLoadAddress != options.compTarget.machine.PROGRAM_LOAD_ADDRESS) {
                            errors.err("BASIC output must have load address ${options.compTarget.machine.PROGRAM_LOAD_ADDRESS.toHex()}", program.toplevelModule.position)
                        }
                        asmgen.out("; ---- basic program with sys call ----")
                        asmgen.out("* = ${program.actualLoadAddress.toHex()}")
                        val year = LocalDate.now().year
                        asmgen.out("  .word  (+), $year")
                        asmgen.out("  .null  $9e, format(' %d ', prog8_entrypoint), $3a, $8f, ' prog8'")
                        asmgen.out("+\t.word  0")
                        asmgen.out("prog8_entrypoint\t; assembly code starts here\n")
                        if(!options.noSysInit)
                            asmgen.out("  jsr  ${compTarget.name}.init_system")
                        asmgen.out("  jsr  ${compTarget.name}.init_system_phase2")
                    }
                    CbmPrgLauncherType.NONE -> {
                        asmgen.out("; ---- program without basic sys call ----")
                        asmgen.out("* = ${program.actualLoadAddress.toHex()}\n")
                        if(!options.noSysInit)
                            asmgen.out("  jsr  ${compTarget.name}.init_system")
                        asmgen.out("  jsr  ${compTarget.name}.init_system_phase2")
                    }
                }
            }
            OutputType.XEX -> {
                asmgen.out("; ---- atari xex program ----")
                asmgen.out("* = ${program.actualLoadAddress.toHex()}\n")
                if(!options.noSysInit)
                    asmgen.out("  jsr  ${compTarget.name}.init_system")
                asmgen.out("  jsr  ${compTarget.name}.init_system_phase2")
            }
        }

        if(options.zeropage !in arrayOf(ZeropageType.BASICSAFE, ZeropageType.DONTUSE)) {
            asmgen.out("""
                ; zeropage is clobbered so we need to reset the machine at exit
                lda  #>sys.reset_system
                pha
                lda  #<sys.reset_system
                pha""")
        }

        // make sure that on the cx16 and c64, basic rom is banked in again when we exit the program
        when(compTarget.name) {
            "cx16" -> {
                if(options.floats)
                    asmgen.out("  lda  #4 |  sta  $01")    // to use floats, make sure Basic rom is banked in
                asmgen.out("  jsr  main.start |  lda  #4 |  sta  $01 |  rts")
            }
            "c64" -> asmgen.out("  jsr  main.start |  lda  #31 |  sta  $01 |  rts")
            else -> asmgen.jmp("main.start")
        }
    }

    private fun memorySlabs() {
        asmgen.out("; memory slabs")
        asmgen.out("prog8_slabs\t.block")
        for((name, info) in allocator.memorySlabs) {
            if(info.second>1u)
                asmgen.out("\t.align  ${info.second.toHex()}")
            asmgen.out("$name\t.fill  ${info.first}")
        }
        asmgen.out("\t.bend")
    }

    private fun footer() {
        // the global list of all floating point constants for the whole program
        asmgen.out("; global float constants")
        for (flt in allocator.globalFloatConsts) {
            val floatFill = compTarget.machine.getFloat(flt.key).makeFloatFillAsm()
            val floatvalue = flt.key
            asmgen.out("${flt.value}\t.byte  $floatFill  ; float $floatvalue")
        }

        // program end
        asmgen.out("prog8_program_end\t; end of program label for progend()")
    }

    private fun block2asm(block: Block) {
        asmgen.out("")
        asmgen.out("; ---- block: '${block.name}' ----")
        if(block.address!=null)
            asmgen.out("* = ${block.address!!.toHex()}")
        else {
            if("align_word" in block.options())
                asmgen.out("\t.align 2")
            else if("align_page" in block.options())
                asmgen.out("\t.align $100")
        }

        asmgen.out("${block.name}\t" + (if("force_output" in block.options()) ".block\n" else ".proc\n"))

        asmgen.outputSourceLine(block)

        zeropagevars2asm(block)
        memdefsAndConsts2asm(block)
        asmsubs2asm(block.statements)
        nonZpVariables2asm(block)

        asmgen.out("")
        asmgen.out("; subroutines in this block")

        // First translate regular statements, and then put the subroutines at the end.
        // (regular statements = everything except the initialization assignments;
        // these will be part of the prog8_init_vars init routine generated below)
        val initializers = blockVariableInitializers.getValue(block)
        val statements = block.statements.filterNot { it in initializers }
        val (subroutine, stmts) = statements.partition { it is Subroutine }
        stmts.forEach { asmgen.translate(it) }
        subroutine.forEach { asmgen.translate(it) }

        if(!options.dontReinitGlobals) {
            // generate subroutine to initialize block-level (global) variables
            if (initializers.isNotEmpty()) {
                asmgen.out("prog8_init_vars\t.proc\n")
                initializers.forEach { assign -> asmgen.translate(assign) }
                asmgen.out("  rts\n  .pend")
            }
        }

        asmgen.out(if("force_output" in block.options()) "\n\t.bend\n" else "\n\t.pend\n")
    }

    internal fun translateSubroutine(sub: Subroutine) {
        var onlyVariables = false

        if(sub.inline) {
            if(options.optimize) {
                if(sub.isAsmSubroutine || callGraph.unused(sub))
                    return

                // from an inlined subroutine only the local variables are generated,
                // all other code statements are omitted in the subroutine itself
                // (they've been inlined at the call site, remember?)
                onlyVariables = true
            }
        }

        asmgen.out("")

        if(sub.isAsmSubroutine) {
            if(sub.asmAddress!=null)
                return  // already done at the memvars section

            // asmsub with most likely just an inline asm in it
            asmgen.out("${sub.name}\t.proc")
            sub.statements.forEach { asmgen.translate(it) }
            asmgen.out("  .pend\n")
        } else {
            // regular subroutine
            asmgen.out("${sub.name}\t.proc")
            zeropagevars2asm(sub)
            memdefsAndConsts2asm(sub)
            asmsubs2asm(sub.statements)

            // the main.start subroutine is the program's entrypoint and should perform some initialization logic
            if(sub.name=="start" && sub.definingBlock.name=="main")
                entrypointInitialization()

            if(functioncallAsmGen.optimizeIntArgsViaRegisters(sub)) {
                asmgen.out("; simple int arg(s) passed via register(s)")
                if(sub.parameters.size==1) {
                    val dt = sub.parameters[0].type
                    val target = AsmAssignTarget(TargetStorageKind.VARIABLE, program, asmgen, dt, sub, variableAsmName = sub.parameters[0].name)
                    if(dt in ByteDatatypes)
                        asmgen.assignRegister(RegisterOrPair.A, target)
                    else
                        asmgen.assignRegister(RegisterOrPair.AY, target)
                } else {
                    require(sub.parameters.size==2)
                    // 2 simple byte args, first in A, second in Y
                    val target1 = AsmAssignTarget(TargetStorageKind.VARIABLE, program, asmgen, sub.parameters[0].type, sub, variableAsmName = sub.parameters[0].name)
                    val target2 = AsmAssignTarget(TargetStorageKind.VARIABLE, program, asmgen, sub.parameters[1].type, sub, variableAsmName = sub.parameters[1].name)
                    asmgen.assignRegister(RegisterOrPair.A, target1)
                    asmgen.assignRegister(RegisterOrPair.Y, target2)
                }
            }

            if(!onlyVariables) {
                asmgen.out("; statements")
                sub.statements.forEach { asmgen.translate(it) }
            }

            asmgen.out("; variables")
            val asmGenInfo = allocator.subroutineExtra(sub)
            for((dt, name, addr) in asmGenInfo.extraVars) {
                if(addr!=null)
                    asmgen.out("$name = $addr")
                else when(dt) {
                    DataType.UBYTE -> asmgen.out("$name    .byte  0")
                    DataType.UWORD -> asmgen.out("$name    .word  0")
                    else -> throw AssemblyError("weird dt")
                }
            }
            if(asmGenInfo.usedRegsaveA)      // will probably never occur
                asmgen.out("prog8_regsaveA     .byte  0")
            if(asmGenInfo.usedRegsaveX)
                asmgen.out("prog8_regsaveX     .byte  0")
            if(asmGenInfo.usedRegsaveY)
                asmgen.out("prog8_regsaveY     .byte  0")
            if(asmGenInfo.usedFloatEvalResultVar1)
                asmgen.out("$subroutineFloatEvalResultVar1    .byte  0,0,0,0,0")
            if(asmGenInfo.usedFloatEvalResultVar2)
                asmgen.out("$subroutineFloatEvalResultVar2    .byte  0,0,0,0,0")
            nonZpVariables2asm(sub)
            asmgen.out("  .pend\n")
        }
    }

    private fun entrypointInitialization() {
        asmgen.out("; program startup initialization")
        asmgen.out("  cld")
        if(!options.dontReinitGlobals) {
            blockVariableInitializers.forEach {
                if (it.value.isNotEmpty())
                    asmgen.out("  jsr  ${it.key.name}.prog8_init_vars")
            }
        }

        // string and array variables in zeropage that have initializer value, should be initialized
        val stringVarsWithInitInZp = allocator.zeropageVars.filter { it.value.dt==DataType.STR && it.value.initialStringValue!=null }
        val arrayVarsWithInitInZp = allocator.zeropageVars.filter { it.value.dt in ArrayDatatypes && it.value.initialArrayValue!=null }
        if(stringVarsWithInitInZp.isNotEmpty() || arrayVarsWithInitInZp.isNotEmpty()) {
            asmgen.out("; zp str and array initializations")
            stringVarsWithInitInZp.forEach {
                val name = asmgen.asmVariableName(it.key)
                asmgen.out("""
                    lda  #<${name}
                    ldy  #>${name}
                    sta  P8ZP_SCRATCH_W1
                    sty  P8ZP_SCRATCH_W1+1
                    lda  #<${name}_init_value
                    ldy  #>${name}_init_value
                    jsr  prog8_lib.strcpy""")
            }
            arrayVarsWithInitInZp.forEach {
                val size = it.value.size
                val name = asmgen.asmVariableName(it.key)
                asmgen.out("""
                    lda  #<${name}_init_value
                    ldy  #>${name}_init_value
                    sta  cx16.r0L
                    sty  cx16.r0H
                    lda  #<${name}
                    ldy  #>${name}
                    sta  cx16.r1L
                    sty  cx16.r1H
                    lda  #<$size
                    ldy  #>$size
                    jsr  sys.memcopy""")
            }
            asmgen.out("  jmp  +")
        }

        stringVarsWithInitInZp.forEach {
            val varname = asmgen.asmVariableName(it.key)+"_init_value"
            val stringvalue = it.value.initialStringValue!!
            outputStringvar(varname, it.value.dt, stringvalue.encoding, stringvalue.value)
        }

        arrayVarsWithInitInZp.forEach {
            val varname = asmgen.asmVariableName(it.key)+"_init_value"
            arrayVariable2asm(varname, it.value.dt, it.value.initialArrayValue!!, null)
        }

        asmgen.out("""+       tsx
                    stx  prog8_lib.orig_stackpointer    ; required for sys.exit()                    
                    ldx  #255       ; init estack ptr
                    clv
                    clc""")
    }

    private fun zeropagevars2asm(scope: INameScope) {
        val zpVariables = allocator.zeropageVars.filter { it.value.originalScope==scope }
        for ((scopedName, zpvar) in zpVariables) {
            if (scopedName.size == 2 && scopedName[0] == "cx16" && scopedName[1][0] == 'r' && scopedName[1][1].isDigit())
                continue        // The 16 virtual registers of the cx16 are not actual variables in zp, they're memory mapped
            asmgen.out("${scopedName.last()} \t= ${zpvar.address} \t; zp ${zpvar.dt}")
        }
    }

    private fun nonZpVariables2asm(block: Block) {
        val variables = variables.blockVars[block]?.filter { !allocator.isZpVar(it.scopedname) } ?: emptyList()
        nonZpVariables2asm(variables)
    }

    private fun nonZpVariables2asm(sub: Subroutine) {
        val variables = variables.subroutineVars[sub]?.filter { !allocator.isZpVar(it.scopedname) } ?: emptyList()
        nonZpVariables2asm(variables)
    }

    private fun nonZpVariables2asm(variables: List<IVariablesAndConsts.StaticVariable>) {
        asmgen.out("")
        asmgen.out("; non-zeropage variables")
        val (stringvars, othervars) = variables.partition { it.type==DataType.STR }
        stringvars.forEach {
            val stringvalue = it.initialValue as StringLiteral
            outputStringvar(it.scopedname.last(), it.type, stringvalue.encoding, stringvalue.value)
        }
        othervars.sortedBy { it.type }.forEach {
            staticVariable2asm(it)
        }
    }

    private fun staticVariable2asm(variable: IVariablesAndConsts.StaticVariable) {
        val name = variable.scopedname.last()
        val value = variable.initialValue
        val staticValue: Number =
            if(value!=null) {
                if(value is NumericLiteral) {
                    if(value.type== DataType.FLOAT)
                        value.number
                    else
                        value.number.toInt()
                } else {
                    if(variable.type in NumericDatatypes)
                        throw AssemblyError("can only deal with constant numeric values for global vars")
                    else 0
                }
            } else 0

        when (variable.type) {
            DataType.UBYTE -> asmgen.out("$name\t.byte  ${staticValue.toHex()}")
            DataType.BYTE -> asmgen.out("$name\t.char  $staticValue")
            DataType.UWORD -> asmgen.out("$name\t.word  ${staticValue.toHex()}")
            DataType.WORD -> asmgen.out("$name\t.sint  $staticValue")
            DataType.FLOAT -> {
                if(staticValue==0) {
                    asmgen.out("$name\t.byte  0,0,0,0,0  ; float")
                } else {
                    val floatFill = compTarget.machine.getFloat(staticValue).makeFloatFillAsm()
                    asmgen.out("$name\t.byte  $floatFill  ; float $staticValue")
                }
            }
            DataType.STR -> {
                throw AssemblyError("all string vars should have been interned into prog")
            }
            in ArrayDatatypes -> arrayVariable2asm(name, variable.type, value as? ArrayLiteral, variable.arraysize)
            else -> {
                throw AssemblyError("weird dt")
            }
        }
    }

    private fun arrayVariable2asm(varname: String, dt: DataType, value: ArrayLiteral?, orNumberOfZeros: Int?) {
        when(dt) {
            DataType.ARRAY_UB -> {
                val data = makeArrayFillDataUnsigned(dt, value, orNumberOfZeros)
                if (data.size <= 16)
                    asmgen.out("$varname\t.byte  ${data.joinToString()}")
                else {
                    asmgen.out(varname)
                    for (chunk in data.chunked(16))
                        asmgen.out("  .byte  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_B -> {
                val data = makeArrayFillDataSigned(dt, value, orNumberOfZeros)
                if (data.size <= 16)
                    asmgen.out("$varname\t.char  ${data.joinToString()}")
                else {
                    asmgen.out(varname)
                    for (chunk in data.chunked(16))
                        asmgen.out("  .char  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_UW -> {
                val data = makeArrayFillDataUnsigned(dt, value, orNumberOfZeros)
                if (data.size <= 16)
                    asmgen.out("$varname\t.word  ${data.joinToString()}")
                else {
                    asmgen.out(varname)
                    for (chunk in data.chunked(16))
                        asmgen.out("  .word  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_W -> {
                val data = makeArrayFillDataSigned(dt, value, orNumberOfZeros)
                if (data.size <= 16)
                    asmgen.out("$varname\t.sint  ${data.joinToString()}")
                else {
                    asmgen.out(varname)
                    for (chunk in data.chunked(16))
                        asmgen.out("  .sint  " + chunk.joinToString())
                }
            }
            DataType.ARRAY_F -> {
                val array = value?.value ?:
                                Array(orNumberOfZeros!!) { defaultZero(ArrayToElementTypes.getValue(dt), Position.DUMMY) }
                val floatFills = array.map {
                    val number = (it as NumericLiteral).number
                    compTarget.machine.getFloat(number).makeFloatFillAsm()
                }
                asmgen.out(varname)
                for (f in array.zip(floatFills))
                    asmgen.out("  .byte  ${f.second}  ; float ${f.first}")
            }
            else -> throw AssemblyError("require array dt")
        }
    }

    private fun memdefsAndConsts2asm(block: Block) {
        val mvs = variables.blockMemvars[block] ?: emptySet()
        val consts = variables.blockConsts[block] ?: emptySet()
        memdefsAndConsts2asm(mvs, consts)
    }

    private fun memdefsAndConsts2asm(sub: Subroutine) {
        val mvs = variables.subroutineMemvars[sub] ?: emptySet()
        val consts = variables.subroutineConsts[sub] ?: emptySet()
        memdefsAndConsts2asm(mvs, consts)
    }

    private fun memdefsAndConsts2asm(
        memvars: Set<IVariablesAndConsts.MemoryMappedVariable>,
        consts: Set<IVariablesAndConsts.ConstantNumberSymbol>
    ) {
        memvars.forEach {
            asmgen.out("  ${it.scopedname.last()} = ${it.address.toHex()}")
        }
        consts.forEach {
            if(it.type==DataType.FLOAT)
                asmgen.out("  ${it.scopedname.last()} = ${it.value}")
            else
                asmgen.out("  ${it.scopedname.last()} = ${it.value.toHex()}")
        }
    }

    private fun asmsubs2asm(statements: List<Statement>) {
        statements
            .filter { it is Subroutine && it.isAsmSubroutine && it.asmAddress!=null }
            .forEach { asmsub ->
                asmsub as Subroutine
                asmgen.out("  ${asmsub.name} = ${asmsub.asmAddress!!.toHex()}")
            }
    }

    private fun outputStringvar(varname: String, dt: DataType, encoding: Encoding, value: String) {
        asmgen.out("$varname\t; $dt $encoding:\"${escape(value).replace("\u0000", "<NULL>")}\"")
        val bytes = compTarget.encodeString(value, encoding).plus(0.toUByte())
        val outputBytes = bytes.map { "$" + it.toString(16).padStart(2, '0') }
        for (chunk in outputBytes.chunked(16))
            asmgen.out("  .byte  " + chunk.joinToString())
    }

    private fun makeArrayFillDataUnsigned(dt: DataType, value: ArrayLiteral?, orNumberOfZeros: Int?): List<String> {
        val array = value?.value ?:
                        Array(orNumberOfZeros!!) { defaultZero(ArrayToElementTypes.getValue(dt), Position.DUMMY) }
        return when (dt) {
            DataType.ARRAY_UB ->
                // byte array can never contain pointer-to types, so treat values as all integers
                array.map {
                    val number = (it as NumericLiteral).number.toInt()
                    "$"+number.toString(16).padStart(2, '0')
                }
            DataType.ARRAY_UW -> array.map {
                when (it) {
                    is NumericLiteral -> {
                        "$" + it.number.toInt().toString(16).padStart(4, '0')
                    }
                    is AddressOf -> {
                        asmgen.asmSymbolName(it.identifier)
                    }
                    is IdentifierReference -> {
                        asmgen.asmSymbolName(it)
                    }
                    else -> throw AssemblyError("weird array elt dt")
                }
            }
            else -> throw AssemblyError("invalid dt")
        }
    }

    private fun makeArrayFillDataSigned(dt: DataType, value: ArrayLiteral?, orNumberOfZeros: Int?): List<String> {
        val array = value?.value ?:
                        Array(orNumberOfZeros!!) { defaultZero(ArrayToElementTypes.getValue(dt), Position.DUMMY) }
        return when (dt) {
            DataType.ARRAY_UB ->
                // byte array can never contain pointer-to types, so treat values as all integers
                array.map {
                    val number = (it as NumericLiteral).number.toInt()
                    "$"+number.toString(16).padStart(2, '0')
                }
            DataType.ARRAY_B ->
                // byte array can never contain pointer-to types, so treat values as all integers
                array.map {
                    val number = (it as NumericLiteral).number.toInt()
                    val hexnum = number.absoluteValue.toString(16).padStart(2, '0')
                    if(number>=0)
                        "$$hexnum"
                    else
                        "-$$hexnum"
                }
            DataType.ARRAY_UW -> array.map {
                val number = (it as NumericLiteral).number.toInt()
                "$" + number.toString(16).padStart(4, '0')
            }
            DataType.ARRAY_W -> array.map {
                val number = (it as NumericLiteral).number.toInt()
                val hexnum = number.absoluteValue.toString(16).padStart(4, '0')
                if(number>=0)
                    "$$hexnum"
                else
                    "-$$hexnum"
            }
            else -> throw AssemblyError("invalid dt")
        }
    }

}
